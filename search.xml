<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>51nod 1315 合法整数集</title>
    <url>/2018/08/23/51nod1315/</url>
    <content><![CDATA[<p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1315">题面</a></p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p>首先，一个数或上<span class="math inline">\(x\)</span>后无法得到<span class="math inline">\(x\)</span>，那么这个数就不用删掉</p>
<p>根据或运算的性质，可得，要让<span class="math inline">\(Fun(SubS) != x\)</span>，则所有元素或起来的结果的二进制表示与<span class="math inline">\(x\)</span>的相比，至少有一个位置没有<span class="math inline">\(1\)</span>,而<span class="math inline">\(x\)</span>有</p>
<p>贪心地想，只要找到一个<span class="math inline">\(x\)</span>二进制为<span class="math inline">\(1\)</span>的位置,这个位置在<span class="math inline">\(A\)</span>中可能或起来得到<span class="math inline">\(x\)</span>的元素中为<span class="math inline">\(1\)</span>的次数最小，这个次数就是答案了</p>
<p>注意无法或出<span class="math inline">\(x\)</span>的数字不需要预处理</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 55 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">2</span>) + ret,ret += ret + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x: y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> t,n,x,top,ans(<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">   read(n),read(x);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++)</span><br><span class="line"> &#123;</span><br><span class="line">        read(t);</span><br><span class="line">      <span class="keyword">if</span>((t | x) != x) <span class="keyword">continue</span>;<span class="comment">//无法得到x</span></span><br><span class="line">      top = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(t) num[++top] += (t &amp; <span class="number">1</span>),t &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">   &#125;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x &amp;&amp; ans)</span><br><span class="line">  &#123;</span><br><span class="line">        ++top;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = Min(ans,num[top]);</span><br><span class="line">       x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1799 二分答案</title>
    <url>/2018/08/06/51nod1799/</url>
    <content><![CDATA[<p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1799">传送门</a></p>
<p>对，这题的确跟二分搜索没太大关系</p>
<p>但还是加一个二分的标签吧2333</p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<ul>
<li><a href="http://www.wikiwand.com/zh/%E6%9C%9F%E6%9C%9B%E5%80%BC">期望是啥</a></li>
<li>其实就是求有多少种排列使得二分最后<span class="math inline">\(r = k\)</span></li>
<li>二分过程中，决定下一步向哪儿走的自然是<span class="math inline">\(mid\)</span>处的值</li>
<li>如果此时<span class="math inline">\(mid \leq k\)</span>,要使最终<span class="math inline">\(r = k\)</span>,则必有<span class="math inline">\(a[mid] \leq m\)</span></li>
<li><span class="math inline">\(mid \gt k \rightarrow a[mid] \gt m\)</span></li>
<li>成为<span class="math inline">\(mid\)</span>的数的位置是确定了的,我们只用确保这些位置上的数满足上述约束条件即可</li>
<li>剩下的数无论怎么排都对答案没影响，所有方案数就是个阶乘，与满足上面的相乘便是答案</li>
<li>将部分阶乘打表(每隔<span class="math inline">\(1e7\)</span>打一个)，使得计算次数在<span class="math inline">\(10^7\)</span>之内</li>
</ul>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000005</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">2</span>) + ret,ret += ret + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>,blo = <span class="number">1e7</span>;</span><br><span class="line">ll fact[] = &#123;<span class="number">1</span>,<span class="number">682498929</span>,<span class="number">491101308</span>,<span class="number">76479948</span>,<span class="number">723816384</span>,<span class="number">67347853</span>,<span class="number">27368307</span>,<span class="number">625544428</span>,<span class="number">199888908</span>,<span class="number">888050723</span>,<span class="number">927880474</span>,<span class="number">281863274</span>, <span class="number">661224977</span>, <span class="number">623534362</span>, <span class="number">970055531</span>, <span class="number">261384175</span>, <span class="number">195888993</span>,<span class="number">66404266</span>, <span class="number">547665832</span>, <span class="number">109838563</span>, <span class="number">933245637</span>, <span class="number">724691727</span>, <span class="number">368925948</span>,</span><br><span class="line"><span class="number">268838846</span>,<span class="number">136026497</span>,<span class="number">112390913</span>,<span class="number">135498044</span>,<span class="number">217544623</span>,<span class="number">419363534</span>,<span class="number">500780548</span>,<span class="number">668123525</span>,<span class="number">128487469</span>,<span class="number">30977140</span>,<span class="number">522049725</span>, <span class="number">309058615</span>,<span class="number">386027524</span>, <span class="number">189239124</span>, <span class="number">148528617</span>, <span class="number">940567523</span>, <span class="number">917084264</span>, <span class="number">429277690</span>,</span><br><span class="line"><span class="number">996164327</span>,<span class="number">358655417</span>,<span class="number">568392357</span>,<span class="number">780072518</span>,<span class="number">462639908</span>,<span class="number">275105629</span>,<span class="number">909210595</span>,<span class="number">99199382</span>,<span class="number">703397904</span>,<span class="number">733333339</span>,<span class="number">97830135</span>, <span class="number">608823837</span>,<span class="number">256141983</span>, <span class="number">141827977</span>, <span class="number">696628828</span>, <span class="number">637939935</span>, <span class="number">811575797</span>, <span class="number">848924691</span>,<span class="number">131772368</span>, <span class="number">724464507</span>, <span class="number">272814771</span>, <span class="number">326159309</span>, <span class="number">456152084</span>, <span class="number">903466878</span>,</span><br><span class="line"><span class="number">92255682</span>,<span class="number">769795511</span>,<span class="number">373745190</span>,<span class="number">606241871</span>,<span class="number">825871994</span>,<span class="number">957939114</span>,<span class="number">435887178</span>,<span class="number">852304035</span>,<span class="number">663307737</span>,<span class="number">375297772</span>,<span class="number">217598709</span>, <span class="number">624148346</span>,<span class="number">671734977</span>, <span class="number">624500515</span>, <span class="number">748510389</span>, <span class="number">203191898</span>, <span class="number">423951674</span>, <span class="number">629786193</span>,</span><br><span class="line"><span class="number">672850561</span>,<span class="number">814362881</span>, <span class="number">823845496</span>,<span class="number">116667533</span>,<span class="number">256473217</span>,<span class="number">627655552</span>,<span class="number">245795606</span>,<span class="number">586445753</span>,<span class="number">172114298</span>,<span class="number">193781724</span>,<span class="number">778983779</span>, <span class="number">83868974</span>,<span class="number">315103615</span>, <span class="number">965785236</span>, <span class="number">492741665</span>, <span class="number">377329025</span>, <span class="number">847549272</span>, <span class="number">698611116</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ll ret = fact[x / blo];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i(x / blo * blo + <span class="number">1</span>);i &lt;= x;i++)</span><br><span class="line">     ret = (ret * i) % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//想想最后怎么让r = m</span></span><br><span class="line"><span class="comment">//每一次二分的位置都与mid处的值有关，故只用关心mid处的值</span></span><br><span class="line"><span class="comment">//如k在mid左边，则必有a[mid] &gt; m,否则a[mid] &lt;= m</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n,m,k,cl(<span class="number">0</span>),cr(<span class="number">0</span>),l,r,mid;<span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    read(n),read(m),read(k);</span><br><span class="line">  l = <span class="number">1</span>,r = n;</span><br><span class="line">  <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line"> &#123;</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span>(mid &lt;= k) l = mid + <span class="number">1</span>,++cl;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>,++cr;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(m - cl + <span class="number">1</span>);i &lt;= m;i++)<span class="comment">//&lt;=m的数</span></span><br><span class="line">     ans = (ans * i) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(n - m - cr + <span class="number">1</span>);i &lt;= n - m;i++)<span class="comment">//n - m - cr!</span></span><br><span class="line">      ans = (ans * i) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(ans * cal(n - cl - cr)) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1009D Relatively Prime Graph</title>
    <url>/2018/07/24/CF1009D%20Relatively%20Prime%20Graph/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="https://codeforces.com/contest/1009/problem/D">题目</a>大意</h2>
<p>定义一个无向图 <span class="math inline">\(G = (V,E)\)</span> 为相邻互质时,当且仅当 <span class="math inline">\(\forall (u,v) \in E,GCD(u,v) = 1\)</span> 给定点数 <span class="math inline">\(n\)</span> 和边数 <span class="math inline">\(m\)</span> ,问能否构成一个相邻互质图,若能,任意输出一种方案</p>
<p>你比如说这个: <img src="https://codeforces.com/predownloaded/e6/1a/e61a341f8b20d0e351ba708597ce43b451f51e25.png" alt="1" /> <a id="more"></a></p>
<h2 id="solution">Solution</h2>
<ul>
<li>显然可以想到 <span class="math inline">\(O(n^2logn)\)</span> 的方法,直接暴力枚举端点,条件成立则在两点之间加一条边</li>
<li>但是,对于 <span class="math inline">\(n \leq 10^5\)</span> 的数据来说.......</li>
<li><strong>居然可以过!!</strong></li>
<li>你也许想说数据水,但是,这可是<strong>Codeforces</strong>啊</li>
<li>我们来看看真的时间复杂度
<ul>
<li>首先,对于 <span class="math inline">\(a,b \in [1,n]\)</span> ,使 <span class="math inline">\(GCD(a,b) = 1\)</span> 的<span class="math inline">\((a,b)\)</span>的组数为 <span class="math display">\[\sum_{i = 1}^n \varphi(i)\]</span></li>
<li>证明:想想 <span class="math inline">\(\varphi(i)\)</span> 的定义是<del>蛤</del>啥</li>
</ul>
<blockquote>
<p>在数论中，对正整数 <span class="math inline">\(n\)</span> ，欧拉函数 <span class="math inline">\(\varphi (n)\)</span> 是<strong>小于或等于 <span class="math inline">\(n\)</span> 的正整数中与 <span class="math inline">\(n\)</span> 互质的数的数目</strong>。此函数以其首名研究者欧拉命名，它又称为<span class="math inline">\(φ\)</span>函数（由高斯所命名）或是欧拉总计函数（totient function，由西尔维斯特所命名）。 From <a href="https://zh.wikipedia.org/zh-hans/欧拉函数">wikipedia</a></p>
</blockquote>
<ul>
<li>很显然,对吧?</li>
<li>然后我们再来看看 <span class="math inline">\(\sum_{i = 1}^n \varphi(i)\)</span> 的增长</li>
<li>可发现,当<span class="math inline">\(n = 600\)</span>时, <span class="math inline">\(\sum_{i = 1}^n \varphi(i)\)</span> 的值将会大于 <span class="math inline">\(m\)</span> 的最大值 <span class="math inline">\(10^5\)</span></li>
<li>所以这个复杂度可以表示为 <span class="math display">\[ O(n)= \begin{cases} n^2logn, &amp; \text {$n \leq$ 600}  \\ \le  600^2log600, &amp; \text{$n \geq 600$} \end{cases} \]</span></li>
<li>就可以过啦</li>
</ul></li>
</ul>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> y ? gcd(y,x % y) : x;&#125;</span><br><span class="line">pii edge[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n,m,cnt(<span class="number">0</span>);</span><br><span class="line">  read(n),read(m);</span><br><span class="line">  <span class="keyword">if</span>(m &lt; n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;Impossible&quot;</span>);<span class="comment">//无法连通所有点</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">2</span>);i &lt;= n &amp;&amp; cnt &lt; m;i++) edge[++cnt] = <span class="built_in">make_pair</span>(<span class="number">1</span>,i); </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">2</span>);i &lt;= n &amp;&amp; cnt &lt; m;i++)</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j(i + <span class="number">1</span>);j &lt;= n &amp;&amp; cnt &lt; m;j++)</span><br><span class="line">               <span class="keyword">if</span>(gcd(i,j) == <span class="number">1</span>) edge[++cnt] = <span class="built_in">make_pair</span>(i,j);</span><br><span class="line">        <span class="keyword">if</span>(cnt != m) <span class="built_in">printf</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Possible\n&quot;</span>);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= m;i++)</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,edge[i].first,edge[i].second);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1073C Vasya and Robot</title>
    <url>/2018/11/07/CF1073C%20Vasya%20and%20Robot/</url>
    <content><![CDATA[<h2 id="题目大意">题目大意</h2>
<p>从点<span class="math inline">\((0,0)\)</span>出发，有一个长度为<span class="math inline">\(n\)</span>的操作序列，<code>U</code>表示上移动一格，<code>D</code>表示向下移动一格，<code>L</code>表示向左移动一格，<code>R</code>表示向右移动一格。现在要修改一些操作，使得最终走到<span class="math inline">\((x,y)\)</span>，修改的代价为最右边的操作位置-最左边操作的位置+1，没有修改则为0，求最小的修改代价，若无法到达，输出<code>-1</code>。</p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p>注意这个修改操作代价的定义，就是求一个区间的长度。</p>
<p>因此，题目就变成了，修改最短的一个区间，使得序列满足条件。</p>
<p>暴力<span class="math inline">\(O(n^3)\)</span>，枚举每个区间并且计算最终点的坐标。</p>
<p>仔细一想，每个操作都是独立的，因此可以用前缀和来维护一个区间的操作序列后到达的点，<span class="math inline">\(O(n^2)\)</span></p>
<p>显然，区间越大，越容易满足条件，这就是单调性。</p>
<p>于是就可以二分啦，<span class="math inline">\(O(nlogn)\)</span></p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = ret * <span class="number">10</span> + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Abs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="keyword">int</span> ex,ey,n,opx[MAXN],opy[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>),j(<span class="number">0</span>);i + mid - <span class="number">1</span> &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i + mid - <span class="number">1</span>;</span><br><span class="line">        x = opx[i - <span class="number">1</span>] + opx[n] - opx[j],y = opy[i - <span class="number">1</span>] + opy[n] - opy[j]; </span><br><span class="line">        <span class="keyword">if</span>(mid &gt;= Abs(x - ex) + Abs(y - ey) &amp;&amp; ((mid - Abs(x - ex) - Abs(y - ey)) &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>);</span><br><span class="line">    read(ex),read(ey);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>); i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        opx[i] = opx[i - <span class="number">1</span>],opy[i] = opy[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;U&#x27;</span>) ++opy[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;D&#x27;</span>) --opy[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;L&#x27;</span>) --opx[i];</span><br><span class="line">        <span class="keyword">else</span> ++opx[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int l(0),r(n),mid,ans(-1);</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) ans = mid,r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 450D Jzzhu and Cities</title>
    <url>/2018/08/22/CF450D%20Jzzhu%20and%20Cities/</url>
    <content><![CDATA[<h2 id="题目大意">题目大意</h2>
<p><span class="math inline">\(n\)</span> 个城市之间有 <span class="math inline">\(m\)</span> 条公路，和<span class="math inline">\(k\)</span>条铁路，<strong>铁路都是连接首都和其他城市的</strong>，公路和铁路都是双向的，<span class="math inline">\(1\)</span>号城市为首都。为了节约成本，总统决定在首都到其他城市的最短路不变的前提下关闭一些铁路，求最多关闭多少条铁路。</p>
<p><span class="math inline">\(2 \le n\le 10^5 \ , \  1 \le m \le 3 \times 10 ^ 5 \ , \ 1 \le k \le 10^5\)</span></p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p>标准错误做法：不把铁路加进图里，直接从点1跑一遍最短路，再用这个最短路径和这个点相连的铁路长度比较，见下图，铁路长度都是1，正确答案是关闭2条铁路，而按照上诉思路一条也关不了</p>
<figure>
<img src="http://static.zybuluo.com/CWOI2018/w6yloz10jdwlh98ol6kbcbzu/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="1" /><figcaption aria-hidden="true">1</figcaption>
</figure>
<p>真正的做法</p>
<ul>
<li>首先，一条铁路要不想被淘汰，它所连的那个点的最短路就必须得从它那儿走过来，且这个最短路是唯一的</li>
<li>我们在最短路算法中进行松弛操作时，判断当前点（必须是连了铁路的点）更短的路是否是从铁路走过来的，是的话，就标记这条铁路是有用的</li>
<li>需要注意的是，当前点最短路不唯一的情况下，如果存在一条最短路是公路，当前点的铁路就要被淘汰</li>
<li>嗯</li>
</ul>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/priority_queue.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;ll,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,nxt,f;ll w;&#125;e[<span class="number">800005</span>];</span><br><span class="line"><span class="keyword">int</span> n,k,f,head[MAXN],rail[MAXN];ll dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> rd[MAXN],vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   e[++k].v = v,e[k].w = w,e[k].f = f;</span><br><span class="line">   e[k].nxt = head[u],head[u] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> u,v;</span><br><span class="line"> __gnu_pbds::<span class="built_in">priority_queue</span>&lt;pii,greater&lt;pii&gt; &gt;q;</span><br><span class="line"> <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>,q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        u = q.top().second,q.pop();</span><br><span class="line">       <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[v = e[i].v] &gt; dis[u] + e[i].w)</span><br><span class="line">         &#123;</span><br><span class="line">                dis[v] = dis[u] + e[i].w,q.push(<span class="built_in">make_pair</span>(dis[v],v));</span><br><span class="line">               <span class="keyword">if</span>(rd[v]) rail[v] = e[i].f;</span><br><span class="line">          &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rd[v] &amp;&amp; dis[v] == dis[u] + e[i].w &amp;&amp; (!e[i].f)) rail[v] = <span class="number">0</span>; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;ra);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= m;i++)</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w),add_edge(u,v,w),add_edge(v,u,w);</span><br><span class="line">   f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= ra;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;v,&amp;w),rd[v] = <span class="number">1</span>,add_edge(<span class="number">1</span>,v,w),add_edge(v,<span class="number">1</span>,w);</span><br><span class="line">  dijkstra();</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">2</span>);i &lt;= n;i++)</span><br><span class="line">     <span class="keyword">if</span>(rd[i]) cnt += rail[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ra - cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 460C Present</title>
    <url>/2018/08/21/CF460C%20Present/</url>
    <content><![CDATA[<h2 id="题目大意">题目大意</h2>
<p>小明养了 <span class="math inline">\(n\)</span> 盆花，排成一行，从左到右编号为 <span class="math inline">\(1- n\)</span>，初始第 <span class="math inline">\(i\)</span> 盆花高度为 <span class="math inline">\(h_i\)</span>。小明想在暑假的 <span class="math inline">\(m\)</span> 天里每天浇一次花，每次浇花都浇任意相邻的 <span class="math inline">\(w\)</span> 盆花，花被浇过一次就会长高<span class="math inline">\(1cm\)</span>，小明想知道怎样浇花才能使最矮的花最高。</p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p>最大最小<span class="math inline">\(\longrightarrow\)</span>二分！</p>
<p>想到了二分思路就比较明显了，二分最矮的最高高度，<code>check</code>时检查要达到这个高度所需浇水的天数是否大于<span class="math inline">\(m\)</span></p>
<p>当一盆花高度没达到二分的值时，就以它为左端点，向右浇<span class="math inline">\(m\)</span>盆花(这样能保证被浇到的花最多)。所需天数则加上它和二分的值的差。</p>
<p>关键在于浇花这个过程，如果直接一盆盆去浇，就会TLE</p>
<p>这个过程就是一个区间修改、单点查询的过程，就可以用一个数据结构来维护这个浇的水，也可以用差分（写着简单）</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,w;ll a[MAXN],ts[MAXN];<span class="comment">//ts:维护浇的水</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(ll x)</span><span class="comment">//差分！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret(0),sum(0),t;</span><br><span class="line">    <span class="built_in">memset</span>(ts,<span class="number">0</span>,<span class="keyword">sizeof</span>(ts));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n &amp;&amp; ret &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += ts[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i] + sum &lt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += (t = x - a[i] - sum);</span><br><span class="line">            sum += t,ts[Min(n + <span class="number">1</span>,i + w)] -= t;<span class="comment">//n + 1::最后一个点有可能不会改到</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l,r,mid,ans;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,a + i);</span><br><span class="line">    l = <span class="number">1</span>,r = <span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) ans = mid,l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 544D Destroying Roads</title>
    <url>/2018/08/23/CF544D%20Destroying%20Roads/</url>
    <content><![CDATA[<h2 id="题目大意">题目大意</h2>
<p><span class="math inline">\(n\)</span>个点，<span class="math inline">\(m\)</span>条双向边,现在要满足<span class="math inline">\(s1，t1\)</span>之间的距离不超过<span class="math inline">\(l1\)</span>，<span class="math inline">\(s2，t2\)</span>之间的距离不超过<span class="math inline">\(l2\)</span>,最多能删去多少条边</p>
<p><span class="math inline">\(1 \le n \le 3000 \ , \ n - 1 \le m \le min \{3000,\frac{n(n - 1)}{2} \}\)</span></p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p>既然要删去最多的边，那么就只用保留<span class="math inline">\(s1 \to t1\)</span>和<span class="math inline">\(s2 \to t2\)</span>的最短路，其余边都删去</p>
<p>因为他们的最短路有可能有重叠部分，我们就枚举重叠部分，将其删去</p>
<p>真是暴力</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/priority_queue.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3005 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">2</span>) + ret,ret += ret + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Max</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x: y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,nxt,w;&#125;e[<span class="number">6005</span>];</span><br><span class="line"><span class="keyword">int</span> k,head[MAXN],d[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> e[++k].v = v,e[k].w = w;</span><br><span class="line">  e[k].nxt = head[u],head[u] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真暴力</span></span><br><span class="line">__gnu_pbds::<span class="built_in">priority_queue</span>&lt;pii,greater&lt;pii&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span>* dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> u,v;   </span><br><span class="line">  <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"> <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="keyword">sizeof</span>(d[<span class="number">0</span>]));</span><br><span class="line">   dis[s] = <span class="number">0</span>,q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>,s));</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        u = q.top().second,q.pop();</span><br><span class="line">       <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">          <span class="keyword">if</span>(dis[v = e[i].v] &gt; dis[u] + e[i].w)</span><br><span class="line">             dis[v] = dis[u] + e[i].w,q.push(<span class="built_in">make_pair</span>(dis[v],v));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//最多删多少边-&gt;最少保留多少边</span></span><br><span class="line"> <span class="keyword">int</span> n,m,u,v,s1,t1,l1,s2,t2,l2,ans,t,tt,dij;</span><br><span class="line">  read(n),read(m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= m;i++)</span><br><span class="line">     read(u),read(v),add_edge(u,v,<span class="number">1</span>),add_edge(v,u,<span class="number">1</span>);</span><br><span class="line">  read(s1),read(t1),read(l1),read(s2),read(t2),read(l2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++)</span><br><span class="line">     dijkstra(i,d[i]);</span><br><span class="line"> <span class="keyword">if</span>(d[s1][t1] &gt; l1 || d[s2][t2] &gt; l2) <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">        ans = d[s1][t1] + d[s2][t2];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++)<span class="comment">//重复的部分</span></span><br><span class="line">     &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(i);j &lt;= n;j++)</span><br><span class="line">         &#123;</span><br><span class="line">                dij = d[i][j],t = d[s1][i] + dij + d[j][t1],tt = d[s2][i] + dij + d[j][t2];</span><br><span class="line">               <span class="keyword">if</span>(t &lt;= l1 &amp;&amp; tt &lt;= l2) ans = Min(ans,t + tt - dij);</span><br><span class="line">               tt = d[t2][i] + dij + d[j][s2];</span><br><span class="line">               <span class="keyword">if</span>(t &lt;= l1 &amp;&amp; tt &lt;= l2) ans = Min(ans,t + tt - dij);</span><br><span class="line">               t = d[t1][i] + dij + d[j][s1];</span><br><span class="line">                <span class="keyword">if</span>(t &lt;= l1 &amp;&amp; tt &lt;= l2) ans = Min(ans,t + tt - dij);</span><br><span class="line">               tt = d[s2][i] + dij + d[j][t2];</span><br><span class="line">               <span class="keyword">if</span>(t &lt;= l1 &amp;&amp; tt &lt;= l2) ans = Min(ans,t + tt - dij);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,m - ans);</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 954D Fight Against Traffic</title>
    <url>/2018/08/22/CF954D%20Fight%20Against%20Traffic/</url>
    <content><![CDATA[<h2 id="题目大意">题目大意</h2>
<p><span class="math inline">\(n\)</span>个点，<span class="math inline">\(m\)</span>条双向边，边权均为1，现在要在没有直接相连的两点间加一条边，使得<span class="math inline">\(s，t\)</span>两点最短路长度不减小，问有几种加法</p>
<p><span class="math inline">\(2 \leq n \leq 1000 \ , \ 1 \leq m \leq 1000\)</span></p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p>分别以<span class="math inline">\(s，t\)</span>为起点，做两次单源最短路，求出每个点到<span class="math inline">\(s，t\)</span>的最短距离<code>dis1[i]</code>和<code>dis2[i]</code>,接着枚举新边的两点，比较加上新边后两点之间的最短距离(即<code>dis1[i] + dis2[j] + 1</code>)是否不小于原来的最短距离。</p>
<p>如果枚举范围是<span class="math inline">\(i \in [1,n] \ , \ j \in [i + 1,n]\)</span>，<strong>则<code>dis2[1] + dis[1-n]</code>等许多情况没考虑到，所以判断条件还该加上<code>dis1[j] + dis2[i] + 1 &gt;= d</code></strong>.</p>
<p>真是暴力，看题时要多注意注意数据范围</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/priority_queue.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1005 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">2</span>) + ret,ret += ret + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Max</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x: y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,nxt,w;&#125;e[<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> k,head[MAXN],dis1[MAXN],dis2[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN],mp[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[++k].v = v,e[k].w = w;</span><br><span class="line">  e[k].nxt = head[u],head[u] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真暴力</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span>* dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> u,v;</span><br><span class="line"> __gnu_pbds::<span class="built_in">priority_queue</span>&lt;pii,greater&lt;pii&gt; &gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"> <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="keyword">sizeof</span>(dis1));</span><br><span class="line">   dis[s] = <span class="number">0</span>,q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>,s));</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        u = q.top().second,q.pop();</span><br><span class="line">       <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">          <span class="keyword">if</span>(dis[v = e[i].v] &gt; dis[u] + e[i].w)</span><br><span class="line">             dis[v] = dis[u] + e[i].w,q.push(<span class="built_in">make_pair</span>(dis[v],v));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,s,t,u,v,d,ans(<span class="number">0</span>);</span><br><span class="line">    read(n),read(m),read(s),read(t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= m;i++)</span><br><span class="line">     read(u),read(v),add_edge(u,v,<span class="number">1</span>),add_edge(v,u,<span class="number">1</span>),mp[u][v] = mp[v][u] = <span class="number">1</span>;</span><br><span class="line">  dijkstra(s,dis1),dijkstra(t,dis2),d = dis1[t];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j(i + <span class="number">1</span>);j &lt;= n;j++)<span class="comment">//!!!!!</span></span><br><span class="line">         <span class="keyword">if</span>(!mp[i][j] &amp;&amp; dis1[i] + dis2[j] + <span class="number">1</span> &gt;= d &amp;&amp; dis1[j] + dis2[i] + <span class="number">1</span> &gt;= d) ++ans;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 191C Fools and Roads</title>
    <url>/2018/07/25/Fools%20and%20Roads/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="https://vjudge.net/problem/CodeForces-191C">题目</a>大意</h2>
<p>有一颗<span class="math inline">\(n\)</span>个点构成的树。<span class="math inline">\(k\)</span>个操作，每一个操作将<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的路径染色，问最后每条边被染了多少次色</p>
<p><span class="math inline">\(2 \le n \le 10^5 \ , \ 1 \le k \le 10^5\)</span> <a id="more"></a></p>
<h2 id="思路">思路</h2>
<ul>
<li>可以树链剖分水过去</li>
<li>当然，还有更妙的做法：差分</li>
<li>令<span class="math inline">\(op[u]\)</span>表示<span class="math inline">\(u\)</span>到根节点的边被染了多少次色</li>
<li>每一次操作需要<code>++op[u],++op[v]</code></li>
<li>显然，<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>的最近公共祖先到根节点的边被染了2次色，所以要<code>op[lca(u,v)] -= 2</code></li>
<li>询问处理完了后，用一次<span class="math inline">\(dfs\)</span>将每个节点的值累加到相对应的边上</li>
</ul>
<h2 id="code"><code>Code</code></h2>
<ul>
<li><p>倍增求LCA <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k,head[MAXN],p[MAXN][<span class="number">21</span>],dep[MAXN],op[MAXN];<span class="comment">//一点到根节点的路径上的边的修改次数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,nxt,op;&#125;e[MAXN &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++k].v = v;</span><br><span class="line">    e[k].nxt = head[u],head[u] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;p[u][<span class="number">0</span>] = fa,dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= <span class="number">20</span>;i++) p[u][i] = p[p[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>((v = e[i].v) != fa) dfs(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &gt; dep[v]) swap(u,v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">20</span>);i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(dep[p[v][i]] &gt;= dep[u]) v = p[v][i];</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">20</span>);i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(p[v][i] != p[u][i]) v = p[v][i],u = p[u][i];</span><br><span class="line">    <span class="keyword">return</span> p[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span><span class="comment">//dfs1!!!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> v,ret(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span>((v = e[i].v) != fa) ret += (e[i].op = dfs1(v,u));</span><br><span class="line"> <span class="keyword">return</span> ret + op[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n,q,u,v;</span><br><span class="line"> read(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt; n;i++)</span><br><span class="line">      read(u),read(v),add_edge(u,v),add_edge(v,u);</span><br><span class="line">  dfs(<span class="number">1</span>,<span class="number">0</span>);read(q);</span><br><span class="line"> <span class="keyword">while</span>(q--)</span><br><span class="line">   &#123;</span><br><span class="line">        read(u),read(v);</span><br><span class="line">      ++op[u],++op[v],op[query(u,v)] -= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= k;i += <span class="number">2</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,e[i].op == <span class="number">0</span> ? e[i + <span class="number">1</span>].op : e[i].op);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>tarjan</code>,跑得非常快 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k,head[MAXN],p[MAXN],op[MAXN],lca[MAXN];</span><br><span class="line"><span class="keyword">int</span> k1,hq[MAXN];<span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,nxt,op;&#125;e[MAXN &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">que</span>&#123;</span><span class="keyword">int</span> v,nxt,id;<span class="keyword">bool</span> vis;&#125;q[MAXN &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == p[x] ? x : p[x] = find(p[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++k].v = v;</span><br><span class="line">    e[k].nxt = head[u],head[u] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_q</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  q[++k1].v = v,q[k1].id = id,q[k1].vis = <span class="number">0</span>;</span><br><span class="line">    q[k1].nxt = hq[u],hq[u] = k1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;p[u] = u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span>(!vis[v = e[i].v] &amp;&amp; v != fa) tarjan(v,u),p[find(v)] = u;</span><br><span class="line">  vis[u] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i(hq[u]);i != <span class="number">-1</span>;i = q[i].nxt)</span><br><span class="line">      <span class="keyword">if</span>(!q[i].vis &amp;&amp; vis[q[i].v]) lca[q[i].id] = find(q[i].v),q[i].vis = q[i ^ <span class="number">1</span>].vis = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span><span class="comment">//dfs1!!!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v,ret(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span>((v = e[i].v) != fa) ret += (e[i].op = dfs1(v,u));</span><br><span class="line"> <span class="keyword">return</span> ret + op[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n,q,u,v;</span><br><span class="line"> read(n);</span><br><span class="line">  <span class="built_in">memset</span>(hq,k1 = <span class="number">-1</span>,<span class="keyword">sizeof</span>(hq));</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt; n;i++)</span><br><span class="line">      read(u),read(v),add_edge(u,v),add_edge(v,u);</span><br><span class="line">  read(q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= q;i++)</span><br><span class="line">     read(u),read(v),add_q(u,v,i),add_q(v,u,i),++op[u],++op[v];</span><br><span class="line">    tarjan(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= q;i++) op[lca[i]] -= <span class="number">2</span>;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= k;i += <span class="number">2</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,e[i].op == <span class="number">0</span> ? e[i + <span class="number">1</span>].op : e[i].op);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 5692 Snacks</title>
    <url>/2018/07/25/HDU5692%20Snacks/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-5692">传送门</a></p>
<p><del>垃圾百毒</del> <a id="more"></a></p>
<h2 id="solution">Solution</h2>
<ul>
<li>反正我没有想出来树剖怎么做QAQ</li>
<li>首先让0号节点为根节点,那么使得指定路径权值和最大的重点一定在<span class="math inline">\(x\)</span>或<span class="math inline">\(x\)</span>的子树上</li>
<li>问题就变成了求<span class="math inline">\(x\)</span>或<span class="math inline">\(x\)</span>的子树中某点到根节点路径的最大权值和</li>
<li><strong>在<span class="math inline">\(dfs\)</span>序中,一个点的子树对应一个连续的区间</strong></li>
<li>然后就转换为带更改的区间最值问题,可以用线段树来实现</li>
<li>更新时由于点<span class="math inline">\(x\)</span>的值影响其子树中点到根节点路径的权值和,因此要区间更新</li>
</ul>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/STACK:1024000000,1024000000&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Min</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Max</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x : y;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,nxt;&#125;e[MAXN &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>ll mx,lazy;&#125;tree[MAXN &lt;&lt; <span class="number">2</span> | <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> k,idx,head[MAXN],dfn[MAXN],lea[MAXN];</span><br><span class="line">ll tw[MAXN],w[MAXN],dis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   e[++k].v = v;</span><br><span class="line"> e[k].nxt = head[u],head[u] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v;<span class="keyword">if</span>(f != <span class="number">-1</span>) dis[u] = dis[f] + tw[u];</span><br><span class="line">  w[dfn[u] = ++idx] = dis[u];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span>((v = e[i].v) != f) dfs(v,u);</span><br><span class="line">  lea[u] = idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;tree[rt].mx = Max(tree[rt &lt;&lt; <span class="number">1</span>].mx,tree[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tree[rt].lazy)</span><br><span class="line">    &#123;</span><br><span class="line">        ll lazy = tree[rt].lazy;</span><br><span class="line">      tree[rt &lt;&lt; <span class="number">1</span>].mx += lazy,tree[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx += lazy;</span><br><span class="line">        tree[rt &lt;&lt; <span class="number">1</span>].lazy += lazy,tree[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy += lazy;</span><br><span class="line">        tree[rt].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> tree[rt].lazy = tree[rt].mx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l == r)&#123;tree[rt].mx = w[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(l,mid,rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">   build(mid + <span class="number">1</span>,r,rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">   push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> L,R;ll val;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">   &#123;</span><br><span class="line">        tree[rt].mx += val,tree[rt].lazy += val;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= mid) update(l,mid,rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(mid &lt; R) update(mid + <span class="number">1</span>,r,rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tree[rt].mx;</span><br><span class="line">  push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="function">ll <span class="title">ret</span><span class="params">(-(<span class="number">1l</span>l &lt;&lt; <span class="number">50</span>))</span></span>;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= mid) ret = Max(ret,query(l,mid,rt &lt;&lt; <span class="number">1</span>));</span><br><span class="line">   <span class="keyword">if</span>(mid &lt; R) ret = Max(ret,query(mid + <span class="number">1</span>,r,rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T,n,m,ca(<span class="number">0</span>),x,u,v,op;ll t;</span><br><span class="line">   read(T);</span><br><span class="line">  <span class="keyword">while</span>(T--)<span class="comment">//以0为根</span></span><br><span class="line">    &#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(head,k = <span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">       read(n),read(m);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt; n;i++)</span><br><span class="line">          read(u),read(v),add_edge(u,v),add_edge(v,u);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i &lt; n;i++) read(tw[i]);</span><br><span class="line">     dis[<span class="number">0</span>] = tw[<span class="number">0</span>],dfs(<span class="number">0</span>,<span class="number">-1</span>),build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>,++ca);</span><br><span class="line">       <span class="keyword">while</span>(m--)</span><br><span class="line">       &#123;</span><br><span class="line">            read(op),read(x),L = dfn[x],R = lea[x];<span class="comment">//某节点值改变只影响其儿子到根节点的路径权值和的改变</span></span><br><span class="line">           <span class="keyword">if</span>(op == <span class="number">0</span>) read(t),val = t - tw[x],update(<span class="number">1</span>,n,<span class="number">1</span>),tw[x] = t;</span><br><span class="line">         <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,query(<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>DFS序</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 6444 Neko&#39;s loop</title>
    <url>/2018/08/31/Hdu6444%20Neko&#39;s%20Loop/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="https://vjudge.net/problem/HDU-6444">题目</a>大意</h2>
<p>有个人有<span class="math inline">\(n\)</span>个数（一个数为当前点的快乐值）构成的一个圈，他可以从任意一个点开始跳，如果当前点编号为<span class="math inline">\(i\)</span>,则每次只能跳到编号为<span class="math inline">\((i + k) \bmod n\)</span>的数，到一个点即可获得这个点的快乐值，可重复获取。最多可以跳<span class="math inline">\(m\)</span>次，问要使快乐值至少为<span class="math inline">\(s\)</span>，起始时该人至少有多少快乐值</p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p>题目实质其实是求<span class="math inline">\(\max(0,s-maxval)\)</span>,<span class="math inline">\(maxval\)</span>为跳圈能得到的最大快乐值</p>
<blockquote>
<p>由裴蜀定理得，跳圈形成得不同序列（循环节）一共由<span class="math inline">\(cnt = GCD(n,k)\)</span>个，每个序列长<span class="math inline">\(n / cnt\)</span></p>
</blockquote>
<p>所以我们可以枚举起点，在<span class="math inline">\(O(n)\)</span>内求出所有的序列(<del>而不是<span class="math inline">\(O(n^2)\)</span></del>)</p>
<p>对于每个序列，求出其前缀和<span class="math inline">\(sum\)</span>，如果<span class="math inline">\(sum[len] \gt 0\)</span>，则能跑多少圈就跑多少圈(<span class="math inline">\(m / len\)</span>圈)，最后会剩下一段长度为<span class="math inline">\(m \% len\)</span>的序列，要使结果最大，这个序列就得是一个长度至多为<span class="math inline">\(m \% len\)</span>的最大连续子段和。</p>
<p>暴力枚举起点终点？NAIVE</p>
<p>我们用一颗线段树来维护前缀和的最小值，如果终点为<span class="math inline">\(j\)</span>，则长度为<span class="math inline">\(m \% len\)</span>的最大连续子段和为<span class="math inline">\(sum[j] - query(j - m \% len,j)\)</span>。</p>
<p>如果<span class="math inline">\(m \ge len\)</span>时，还要考虑一种情况：整个循环节的和是正数，但是其中有一些负数，这种情况下最优解便是最后一圈不会走这些负数</p>
<p>你比如说这一组数据</p>
<pre><code>1
5 100 12 1
-10 1 2 3 5</code></pre>
<p>最优走法是<span class="math inline">\(1 \to 2 \to 3 \to 5 \to -10 \to 1 \to 2 \to 3 \to 5\)</span>，得到的最大值是<span class="math inline">\(12\)</span></p>
<p>求也很好求，直接整个圈跑<span class="math inline">\((m - len) / m\)</span>次，再求一个最长长度为<span class="math inline">\(len\)</span>的最大连续字段和</p>
<p><del>md被快读卡了将近半天，不写玄学优化了</del></p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = ret * <span class="number">10</span> + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Max</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x: y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Min</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> y ? gcd(y,x % y) : x;&#125;</span><br><span class="line">ll a[MAXN],seq[MAXN &lt;&lt; <span class="number">1</span> | <span class="number">1</span>],sum[MAXN &lt;&lt; <span class="number">1</span> | <span class="number">1</span>],tree[MAXN &lt;&lt; <span class="number">3</span> | <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;tree[rt] = Min(tree[rt &lt;&lt; <span class="number">1</span>],tree[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(l == r)</span><br><span class="line">   &#123;</span><br><span class="line">        tree[rt] = sum[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(l,mid,rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">   build(mid + <span class="number">1</span>,r,rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">   push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> L,R;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tree[rt];</span><br><span class="line"> <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="function">ll <span class="title">ret</span><span class="params">(<span class="number">1e18</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) ret = Min(ret,query(l,mid,rt &lt;&lt; <span class="number">1</span>));</span><br><span class="line">   <span class="keyword">if</span>(mid &lt; R) ret = Min(ret,query(mid + <span class="number">1</span>,r,rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线段树求区间最大和</span></span><br><span class="line"><span class="comment">//巧妙的维护</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T,n,k,cnt,len,Tlen,pos,ca(<span class="number">0</span>);ll s,ans,t,cir,m,tm;</span><br><span class="line">    read(T);</span><br><span class="line">  <span class="keyword">while</span>(T--)</span><br><span class="line">   &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">      read(n),read(s),read(m),read(k);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++) read(a[i]);</span><br><span class="line">     cnt = gcd(n,k),len = n / cnt,Tlen = len &lt;&lt; <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= cnt;i++)</span><br><span class="line">       &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">1</span>);j &lt;= len;j++)</span><br><span class="line">           &#123;</span><br><span class="line">                seq[j] = seq[j + len] = a[pos],pos += k; </span><br><span class="line">             <span class="keyword">if</span>(pos &gt; n) pos %= n;</span><br><span class="line">         &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">1</span>);j &lt;= Tlen;j++) sum[j] = sum[j - <span class="number">1</span>] + seq[j];</span><br><span class="line">            build(<span class="number">1</span>,Tlen,<span class="number">1</span>);</span><br><span class="line">          <span class="comment">//先算m比序列长度多出来的那以部分</span></span><br><span class="line">           tm = m % len,t = cir = <span class="number">0</span>;<span class="comment">//t的初始化在这儿,每次循环都要！！！</span></span><br><span class="line">            <span class="comment">//从序列第一个开始走,直到把m用完获得的最大代价</span></span><br><span class="line">            <span class="keyword">if</span>(sum[len] &gt; <span class="number">0</span>) cir = sum[len] * (m / len);</span><br><span class="line">          <span class="comment">//一圈走完了还有剩下的，枚举走剩下的那部分</span></span><br><span class="line">           <span class="keyword">if</span>(tm)</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j(len + <span class="number">1</span>);j &lt;= Tlen;j++)</span><br><span class="line">                    L = j - tm,R = j,t = Max(t,sum[j] - query(<span class="number">1</span>,Tlen,<span class="number">1</span>));</span><br><span class="line">         ans = Max(ans,t + cir);</span><br><span class="line">           <span class="keyword">if</span>(m &gt;= len)</span><br><span class="line">          &#123;</span><br><span class="line">                <span class="comment">//少跑一圈，以求得更大的值eg：（11 -10）虽然一个圈的值和是正的，但其中有负的值</span></span><br><span class="line">             t = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(sum[len] &gt; <span class="number">0</span>) cir = sum[len] * ((m - len) / len);</span><br><span class="line">              <span class="comment">//求出走len步以内的最大值   </span></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j(len + <span class="number">1</span>);j &lt;= Tlen;j++)</span><br><span class="line">                    L = j - len,R = j,t = Max(t,sum[j] - query(<span class="number">1</span>,Tlen,<span class="number">1</span>));</span><br><span class="line">                ans = Max(ans,t + cir);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>,++ca,Max(<span class="number">0</span>,s - ans));</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA:最近公共祖先</title>
    <url>/2018/07/25/LCA/</url>
    <content><![CDATA[<h2 id="定义">定义</h2>
<ul>
<li>一棵树<span class="math inline">\(T\)</span>上两点 <span class="math inline">\(u,v\)</span> 深度最大的公共祖先</li>
<li>或者说，LCA是 <span class="math inline">\(u,v\)</span> 两点在树上路径中深度最小的点</li>
<li>如下图,<span class="math inline">\(4\)</span>是<span class="math inline">\(2\)</span>和<span class="math inline">\(5\)</span>的最近公共祖先 <img src="https://cdn.luogu.org/upload/pic/2282.png" alt="1" /> <a id="more"></a></li>
</ul>
<h2 id="求法">求法</h2>
<h3 id="暴力">暴力</h3>
<ul>
<li>直接暴力向上跳</li>
<li><span class="math inline">\(O(TLE)\)</span></li>
</ul>
<hr />
<h3 id="倍增">倍增</h3>
<ul>
<li>预处理出<span class="math inline">\(u\)</span>向上跳<span class="math inline">\(2^i\)</span>次方能到达的点(用<code>p[u][i]</code>表示)</li>
<li><span class="math inline">\(u\)</span>向上跳<span class="math inline">\(2^i\)</span>次方能到的点即为<span class="math inline">\(u\)</span>向上跳<span class="math inline">\(2^{i - 1}\)</span>次方能到的点再向上跳<span class="math inline">\(2^{i - 1}\)</span>次方，即</li>
</ul>
<p><span class="math display">\[p[u][i] = p[\ p[u][i - 1]\ ][i - 1]\]</span></p>
<ul>
<li>查询时先将两点跳至同一深度，再一起向上跳。</li>
<li>时间复杂度
<ul>
<li>预处理 <span class="math inline">\(O(n*logn)\)</span></li>
<li>查询 <span class="math inline">\(O(q*logn)\)</span></li>
</ul></li>
<li>代码
<ul>
<li><p>预处理 <figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">void dfs(int u,int fa)</span><br><span class="line">&#123;</span><br><span class="line">    int v;p<span class="comment">[u]</span><span class="comment">[0]</span> = fa,dep<span class="comment">[u]</span> = dep<span class="comment">[fa]</span> + 1;</span><br><span class="line">    for(int i(1);i &lt;= 20;i++) p<span class="comment">[u]</span><span class="comment">[i]</span> = p<span class="comment">[p<span class="comment">[u]</span><span class="comment">[i - 1]</span>]</span><span class="comment">[i - 1]</span>;</span><br><span class="line">    for(int i(head<span class="comment">[u]</span>);i;i = e<span class="comment">[i]</span>.nxt)</span><br><span class="line">        if((v = e<span class="comment">[i]</span>.v) != fa) dfs(v,u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>查询 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &gt; dep[v]) swap(u,v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">20</span>);i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(dep[p[v][i]] &gt;= dep[u]) v = p[v][i];</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">20</span>);i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(p[v][i] != p[u][i]) v = p[v][i],u = p[u][i];</span><br><span class="line">    <span class="keyword">return</span> p[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<hr />
<h3 id="rmq">RMQ</h3>
<blockquote>
<p>欧拉序列:<span class="math inline">\(DFS\)</span>遍历树<span class="math inline">\(T\)</span>，将遍历到的结点按照顺序记下，得到一个长度为<span class="math inline">\(2n – 1\)</span>的序列</p>
</blockquote>
<ul>
<li>记录下该树的欧拉序列时，也记录下每个节点在欧拉序列中第一次出现的位置<code>pos[u]</code>和与欧拉序列对应的每个节点的深度序列</li>
<li>例子</li>
<li>根据<span class="math inline">\(DFS\)</span>的性质，两个节点<span class="math inline">\(u,v\)</span>的最近公共祖先，即为<span class="math inline">\(DFS\)</span>序中在<code>pos[u]</code>和<code>pos[v]</code>间深度最低的点</li>
<li>所以用ST表来预处理区间深度最小的点<code>p[i][j]</code></li>
<li><code>f[i][j] = dep[f[i][j - 1]] &gt; dep[f[i + (1 &lt;&lt; j - 1)][j - 1]] ? f[i][j - 1] : f[i + (1 &lt;&lt; j - 1)][j - 1]</code></li>
<li>时间复杂度
<ul>
<li>预处理 <span class="math inline">\(O(n*logn)\)</span></li>
<li>查询 <span class="math inline">\(O(1)\)</span></li>
</ul></li>
</ul>
<hr />
<h3 id="tarjan">Tarjan</h3>
<ul>
<li>离线算法</li>
<li>步骤
<ul>
<li>从选中的根节点开始<span class="math inline">\(dfs\)</span></li>
<li>每访问到一个新节点<span class="math inline">\(u\)</span>，就将其标记为访问过，并初始化集合<span class="math inline">\(\{ u\}\)</span></li>
<li>遍历其子树，并将其子树的集合合并到它上</li>
<li>处理关于<span class="math inline">\(u\)</span>的询问，如果询问<span class="math inline">\((u,v)\)</span>中<span class="math inline">\(v\)</span>已经被访问过，则<span class="math inline">\((u,v)\)</span>的LCA为<span class="math inline">\(v\)</span>所在集合的代表</li>
</ul></li>
<li>时间复杂度 <span class="math inline">\(O(n + q)\)</span></li>
<li>写的很好的博客 <a href="http://www.cnblogs.com/JVxie/p/4854719.html">JVxie</a></li>
<li>代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> T ret(0),f(1);char ch(getchar());</span><br><span class="line"> <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line"> <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line"> a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"><span class="keyword">int</span> k,k1,head[MAXN],headq[MAXN],p[MAXN],ans[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,nxt;&#125;e[MAXN &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">que</span>&#123;</span><span class="keyword">int</span> v,nxt,id;<span class="keyword">bool</span> vis;&#125;q[MAXN &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];<span class="comment">//from zero</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == p[x] ? x : p[x] = find(p[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++k].v = v;</span><br><span class="line"> e[k].nxt = head[u],head[u] = k;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_q</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   q[++k1].v = v,q[k1].id = id;</span><br><span class="line">  q[k1].nxt = headq[u],headq[u] = k1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v;p[u] = u;<span class="comment">//初始化集合</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span>((!vis[v = e[i].v]) &amp;&amp; v != fa) tarjan(v,u),p[find(v)] = u;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i(headq[u]);i != <span class="number">-1</span>;i = q[i].nxt)</span><br><span class="line">       <span class="keyword">if</span>(!q[i].vis &amp;&amp; vis[q[i].v]) ans[q[i].id] = find(q[i].v),q[i].vis = q[i ^ <span class="number">1</span>].vis = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q,rt,u,v;k1 = <span class="number">-1</span>;</span><br><span class="line">  read(n),read(q),read(rt);</span><br><span class="line"> <span class="built_in">memset</span>(headq,<span class="number">-1</span>,<span class="keyword">sizeof</span>(headq));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt; n;i++)</span><br><span class="line">      read(u),read(v),add_edge(u,v),add_edge(v,u);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= q;i++)</span><br><span class="line">     read(u),read(v),add_q(u,v,i),add_q(v,u,i);</span><br><span class="line">    tarjan(rt,<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= q;i++)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="树剖">树剖</h3>
<ul>
<li>来自lyc(Enzyme125)的优秀方法</li>
<li>只用一个DFS</li>
<li>在DFS中求出每个轻重儿子的父亲是谁，查询时利用并查集的思路快速找到一个点所在的链的顶点。（普通树剖则是在第二个DFS中拉轻重链）</li>
<li>时间复杂度<span class="math inline">\(O(n + qlogn)\)</span></li>
<li>空间复杂度<span class="math inline">\(O(n)\)</span>，在线算法中最优秀</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v,son(<span class="number">0</span>);fa[u] = f,dep[u] = dep[f] + <span class="number">1</span>,sz[u] = <span class="number">1</span>,top[u] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((v = e[i].v) == f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,u),sz[u] += sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[v] &gt; sz[son]) son = v; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son) top[son] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == top[x] ? x : top[x] = find(top[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(find(u) != find(v))</span><br><span class="line">        <span class="keyword">return</span> dep[top[u]] &gt; dep[top[v]] ? query(fa[top[u]],v) : query(u,fa[top[v]]);</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>膜</title>
    <url>/2018/10/11/Mod!/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>HL神犇YXB班级里一共有<span class="math inline">\(N\)</span>位神犇，第<span class="math inline">\(i\)</span>位神犇的力量值为<span class="math inline">\(V_i\)</span>。有一天，这些神犇们按编号顺序坐成了一排，然后依次从左向右膜拜了过去。众所周知，如果一个神犇<span class="math inline">\(A\)</span>膜一个力量不比他强的神犇<span class="math inline">\(B\)</span>，那么他的力量值就会变小，变成<span class="math inline">\(V_A \bmod V_B\)</span>。为了不让顺序混乱，他们决定先由<span class="math inline">\(1\)</span>号神犇起身按编号从小到大顺序膜一遍其他神犇，然后<span class="math inline">\(2\)</span>号神犇再起身，同样按编号从小到大顺序膜一遍剩余的其他神犇，以此类推。这样，第<span class="math inline">\(i\)</span> 位神犇依次膜拜了比他编号大的<span class="math inline">\(N - i\)</span>位神犇。所有神犇都膜完之后，除了<span class="math inline">\(N\)</span>号神犇—— HL神犇YXB 之外，大多数神犇都失去了很多力量，他们已经没有能力写代码啦！所以他们请求一直在旁边一脸黑线看他们膜膜去的你，帮他们计算一下这<span class="math inline">\(N * (N - 1) / 2\)</span>次膜拜中，每次膜拜之后跪倒在地的神犇的剩余力量值（*即求每一次膜拜后，膜的那个人的剩余力量值的总和）。</p>
<p>由于膜拜次数太多啦，你只需要告诉他们这些数的总和即可。</p>
<a id="more"></a>
<h2 id="输入">输入</h2>
<p>第一行一个整数<span class="math inline">\(N\)</span>，表示神犇的个数，其中第<span class="math inline">\(N\)</span>号神犇是HL神犇YXB。</p>
<p>接下来一行<span class="math inline">\(N\)</span>个整数，第<span class="math inline">\(i\)</span>个整数表示<span class="math inline">\(V_i\)</span>。</p>
<h2 id="输出">输出</h2>
<p>输出一个整数，表示这些膜拜发生之后跪倒在地的神犇的力量值之和。由于神犇毕竟是神犇，即使力量变弱也非常强，所以请输出答案对<span class="math inline">\(10^9 + 7\)</span>取模之后的结果。（你也要膜一膜！）</p>
<h2 id="样例输入">样例输入</h2>
<pre><code>5
5 3 2 1000000000</code></pre>
<h2 id="样例输出">样例输出</h2>
<pre><code>6</code></pre>
<h2 id="样例解释">*样例解释</h2>
<p>第一个人开始膜，依次剩余的力量值为<span class="math inline">\(2,0,0\)</span></p>
<p>第二个人开始膜，依次剩余的力量值为<span class="math inline">\(1,1\)</span></p>
<p>第三个人开始膜，依次剩余的力量值为<span class="math inline">\(2\)</span></p>
<p>于是乎，答案为<span class="math inline">\(6\)</span></p>
<h2 id="数据范围">数据范围</h2>
<p><span class="math inline">\(1 \leq N \leq 100000，1 \leq V_i \leq 10^9\)</span></p>
<h2 id="solution">Solution</h2>
<p>暴力非常简单，这儿就不说了。</p>
<p>一个显然的结论：每个人的力量值在膜的过程中是递减的，像一个台阶一样</p>
<p>考虑反着来：既然枚举每一个人向后膜不行，那就可以试试开一个东西记录前面人的力量值，每遇到一个人，都把前面比他大的人的力量值更新。</p>
<p>还有一个结论：能使一个数<span class="math inline">\(x\)</span>有效变小的取模次数至多为<span class="math inline">\(log_2x\)</span>次</p>
<p>证明：设模数为<span class="math inline">\(mod\)</span>,当<span class="math inline">\(mod \gt \frac{n}{2}\)</span>时，余数为<span class="math inline">\(n - mod \in (0,\frac{n}{2})\)</span>；当<span class="math inline">\(mod \leq \frac{n}{2}\)</span>时，显然余数<span class="math inline">\(\in [0,\frac{n}{2})\)</span></p>
<p>于是乎，我们可以用一个优先队列来维护膜拜的人，从前向后遍历序列，如果队头元素大于当前元素，则把答案加上模数乘以对头元素的位置与当前位置之差(别忘了上面那个结论)</p>
<p>注意序列遍历完了，队列可能不为空，记得处理。</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/priority_queue.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T ret(0),f(1);char ch(getchar());</span><br><span class="line"> <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line"> <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = ret * <span class="number">10</span> + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">__gnu_pbds::<span class="built_in">priority_queue</span>&lt;pii&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   freopen(<span class="string">&quot;Orz.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;Orz.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> n,t;<span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;pii u;</span><br><span class="line">    read(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++) read(a[i]);</span><br><span class="line"> q.push(<span class="built_in">make_pair</span>(a[<span class="number">1</span>],<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">2</span>);i &lt;= n;i++)</span><br><span class="line"> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty() &amp;&amp; (q.top().first &gt;= a[i]))</span><br><span class="line">      &#123;</span><br><span class="line">            u = q.top(),q.pop();</span><br><span class="line">          ans = (ans + <span class="number">1l</span>l * u.first * (i - u.second)) % mod;</span><br><span class="line">           t = u.first % a[i];</span><br><span class="line">           <span class="keyword">if</span>(t) q.push(<span class="built_in">make_pair</span>(t,i));</span><br><span class="line">      &#125;</span><br><span class="line">        q.push(<span class="built_in">make_pair</span>(a[i],i));</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) u = q.top(),q.pop(),ans = (ans + <span class="number">1l</span>l * u.first * (n + <span class="number">1</span> - u.second)) % mod;<span class="comment">//还有数哦</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++)</span><br><span class="line"> &#123;</span><br><span class="line">        ans -= a[i];</span><br><span class="line">      <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) ans += mod;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//for(int i(1);i &lt;= n;i++) ans = (ans - a[i] + mod) % mod;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="hits">Hits</h2>
<p>题面中标<code>*</code>的部分都是我自己加上去的，原题面中并没有这些东西</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数据结构</tag>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记</title>
    <url>/2020/08/01/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://www.python.org/static/opengraph-icon-200x200.png" /></p>
<a id="more"></a>
<h2 id="基本操作">基本操作</h2>
<ul>
<li><p>多重赋值</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">a,b = b,a + b <span class="comment"># 即a = b,b = a + b(不能这么写)</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>//</code> 整数除法（除的结果向下取整）</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">5 // 3 =&gt; 1</span><br><span class="line">5.0 // 3.0 =&gt; 1</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="输入输出">输入输出</h2>
<ul>
<li><p><code>input</code></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>var = input(<span class="string">&quot;Please input:&quot;</span>) <span class="comment">#引号内内容在输入前显示</span></span><br><span class="line">Please input:<span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>var</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>注意：<code>input</code>会将换行写入字符串再结束输入</p></li>
<li><p><code>print</code></p>
<ul>
<li><p>在每一个参数项之间会插入一个空格</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&quot;There is&quot;</span>,i,<span class="string">&quot;hamstsers&quot;</span>)</span><br><span class="line">There <span class="keyword">is</span> <span class="number">20</span> hamsters <span class="comment">#注意is、i(20)、hamster间均有一个空格</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>end</code> 可取消输出后的换行，也可用于使用另一字符结尾</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> a &lt; <span class="number">200</span>:</span><br><span class="line">        print(a,end = <span class="string">&quot;,&quot;</span>)</span><br><span class="line">      a,b = b,a + b</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">144</span>,</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>格式化输出依旧使用<code>%</code></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hi,%s, you have $%d.&quot;</span> % (<span class="string">&quot;Tom&quot;</span>,<span class="number">100</span>)</span><br><span class="line"><span class="string">&#x27;Hi Tom,you have $100.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&quot;%03d  %.3f&quot;</span> % (<span class="number">2</span>,<span class="number">3.14159</span>))</span><br><span class="line"><span class="number">002</span> <span class="number">3.142</span> <span class="comment">#(注意此处有四舍五入)</span></span><br></pre></td></tr></table></figure></p>
<p><code>%s</code>：字符串 <code>%f</code>：浮点数 <code>%d</code>：整数 <code>%x</code>：十六进制数</p></li>
</ul>
<h2 id="数字字符串列表">数字、字符串、列表</h2>
<h3 id="数字">数字</h3>
<ul>
<li>用<code>**</code> 表示乘方：<code>2 ** 5</code>即<span class="math inline">\(2 ^ 5 = 32\)</span></li>
</ul>
<h3 id="字符串">字符串</h3>
<ul>
<li><p>原始字符串 (忽略转义字符)</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;C:\some\name&#x27;</span>)  <span class="comment"># here \n means newline!</span></span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r&#x27;C:\some\name&#x27;</span>)  <span class="comment"># note the r before the quote</span></span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure></p></li>
<li><p>字符串可用 <code>+</code>连接，<code>*</code>进行重复</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="string">&#x27;un&#x27;</span> + <span class="string">&#x27;ium&#x27;</span></span><br><span class="line"><span class="string">&#x27;unununium&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>字符串字面值可以跨行连续输入。一种方式是用三重引号：<code>"""..."""</code> 或 <code>'''...'''</code>。字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个 <code>\</code> 即可。如下例:</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;&quot;&quot;\</span></span><br><span class="line"><span class="string">Usage: thingy [OPTIONS]</span></span><br><span class="line"><span class="string">     -h                        Display this usage message</span></span><br><span class="line"><span class="string">     -H hostname               Hostname to connect to</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>将产生如下输出（注意最开始的换行没有包括进来）:</p>
<p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Usage</span>: thingy [<span class="keyword">OPTIONS</span>]</span><br><span class="line">     -h                        Display this <span class="keyword">usage</span> message</span><br><span class="line">     -H hostname               Hostname <span class="keyword">to</span> <span class="keyword">connect</span> <span class="keyword">to</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>字符串数组下表可以为负数，此时表示从右向左数</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;word = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-1</span>]  <span class="comment"># last character</span></span><br><span class="line"><span class="string">&#x27;n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-2</span>]  <span class="comment"># second-last character</span></span><br><span class="line"><span class="string">&#x27;o&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-6</span>]</span><br><span class="line"><span class="string">&#x27;P&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>使用<code>[x:y]</code>来得到一个字符串中的区间（左闭右开）（越界自动处理）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;Py&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">3</span>] <span class="comment">#默认开头为0，结尾为字符串结束</span></span><br><span class="line"><span class="string">&#x27;Pyt&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[::<span class="number">-1</span>] <span class="comment">#翻转 参数同下range(start,end,step)</span></span><br><span class="line">nohtyP</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[::<span class="number">2</span>]</span><br><span class="line">Pto</span><br></pre></td></tr></table></figure></li>
<li><p>注：<strong>Python中字符串不能被修改，即以下的做法是错误的</strong></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">3</span>] = <span class="string">&#x27;s&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>len(s)</code>：序列的元素个数/xx的长度</p></li>
<li><p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#string-methods">一些字符串函数</a></p></li>
</ul>
<h3 id="列表">列表</h3>
<ul>
<li><p>列表类似数组，操作与字符串差不多，但字符串不同的是，其内容可变（相对上述而言）</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list.insert(pos,x) <span class="comment">#在pos位置插入x</span></span><br><span class="line">list.pop() <span class="comment">#删除末尾元素 可填入参数pos</span></span><br><span class="line">list.append(x) <span class="comment">#在末尾插入x</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>tuple</code>一旦初始化后就不能修改（指向不变）的数组</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = (<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>注：如<code>tuple</code>中含有<code>list</code>，则<code>list</code>中元素可变</p></li>
<li><p><code>ord()</code>返回该字符的ASCII或Unicode编码，<code>chr()</code>反之</p></li>
<li><p><code>list.reverse()</code>：翻转</p></li>
</ul>
<h2 id="循环">循环</h2>
<ul>
<li><p><code>for</code>：对任意序列进行迭代所有</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>animal = [<span class="string">&quot;pig&quot;</span>,<span class="string">&quot;hamster&quot;</span>,<span class="string">&quot;monkey&quot;</span>,<span class="string">&quot;pigeon&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> animal:</span><br><span class="line">    print(i,end = <span class="string">&quot; &quot;</span>)</span><br><span class="line">    </span><br><span class="line">pig hamster monkey pigon</span><br></pre></td></tr></table></figure></p></li>
<li><p>如需遍历一指定区域，则用<code>range(start,stop,step)</code>（最后一个参数为公差）（可以只有stop）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>): <span class="comment">#左闭右开</span></span><br><span class="line">    print(animal[i])</span><br><span class="line">  </span><br><span class="line">pig</span><br><span class="line">hamster</span><br></pre></td></tr></table></figure></li>
<li><p>循环可能带有<code>else</code>子句：该语句将在<code>for</code>循环完毕或循环条件变为假值 (使用 <code>while</code>) 时被执行</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">                   print(n,<span class="string">&quot;equals&quot;</span>,x,<span class="string">&quot;*&quot;</span>,n // x)</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">#如果break执行，则else语句将不会被执行</span></span><br><span class="line">          <span class="keyword">else</span>: print(n,<span class="string">&quot;is a prime number&quot;</span>)</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="内置数据结构">内置数据结构</h2>
<ul>
<li><p><code>dict</code>：字典，类似<code>c++</code>中<code>map</code>。注：key应为不可变对象（字符串、整数，<code>list</code>就不行）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&quot;hamster&quot;</span>:<span class="number">22</span>,<span class="string">&quot;piggy&quot;</span>:<span class="number">23</span>,<span class="string">&quot;monkey&quot;</span>:<span class="number">27</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&quot;piggy&quot;</span>]</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&quot;monkey&quot;</span>] = <span class="number">100</span> <span class="comment">#可修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&quot;monkey&quot;</span>]</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="comment">#判断是否存在</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pig <span class="keyword">in</span> d</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt; d.get(<span class="string">&quot;pig&quot;</span>,<span class="number">3</span>) <span class="comment">#若没有则返回3 若有返回该key对应的值</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">&quot;monkey&quot;</span>) <span class="comment">#删除</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>set</code>：同<code>c++</code>中<code>set</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#要用list构造</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">100</span>) <span class="comment">#添加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">2</span>) <span class="comment">#删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2 <span class="comment">#支持集合取交、并操作</span></span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2></li>
<li><p>例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span> <span class="comment">#小于n的斐波那契数</span></span><br><span class="line"> a,b = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"> <span class="keyword">while</span> a &lt; n:</span><br><span class="line">      print(a,end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      a,b = b, a + b</span><br><span class="line">    print()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">2000</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span></span><br></pre></td></tr></table></figure></li>
<li><p>同<code>c++</code>相同，参数可有默认值<code>def f(n = 3)</code></p></li>
<li><p><strong>重要警告：</strong> 默认值只会执行一次。注意默认值为可变对象（列表、字典、etc）时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a, L=[]</span>):</span></span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line">print(f(<span class="number">1</span>))</span><br><span class="line">print(f(<span class="number">2</span>))</span><br><span class="line">print(f(<span class="number">3</span>))</span><br><span class="line"><span class="comment">#结果将为</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>如要规避此情况，可将<code>[]</code>改为<code>None</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a,L = None</span>)</span></span><br><span class="line"><span class="function">   <span class="title">if</span> <span class="title">L</span> <span class="title">is</span> <span class="title">None</span>:</span> L = []</span><br><span class="line">   L.append(a)</span><br><span class="line">   <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure></li>
<li><p>可变参数（即可传入任意个参数）（调用时自动组装为<code>tuple</code>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">*numbers</span>):</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cal(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cal(<span class="number">2</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">#当传入对象为list/tuple时，在传入对象前加*</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cal(*s)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure></li>
<li><p>关键字参数（可传入任意个含参数名的参数）（自动组装为<code>dict</code>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name,age,**kw</span>):</span></span><br><span class="line">   print(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</span><br><span class="line">   <span class="comment">#or:for i in kw: print(i,&quot;:&quot;,kw[i])</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">45</span>, gender=<span class="string">&#x27;M&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, **extra)</span><br><span class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>也可以这样调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">pt</span>(<span class="params">vol = <span class="number">100</span>,state = <span class="string">&quot;stiff&quot;</span>,atcion = <span class="string">&quot;voom&quot;</span></span>):</span></span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pt(vol = <span class="number">100</span>,state = <span class="string">&quot;sfsff&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pt(action = <span class="string">&quot;adsad&quot;</span>,vol = <span class="number">122</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><code>\</code>前的参数仅限位置参数(即不能以<code>key = word</code>的形式传入)，<code>*</code>后的参数仅能以关键字形式(即<code>key = word</code>)传入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age, *, city, job</span>):</span></span><br><span class="line">        print(name, age, city, job)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;Engineer&#x27;</span>) <span class="comment">#Error！</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: person() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="number">12</span>,<span class="number">12</span>,city = <span class="number">12</span>,job = <span class="number">12</span>) <span class="comment">#Correct!</span></span><br><span class="line"><span class="number">12</span> <span class="number">12</span> <span class="number">12</span> <span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name,age,/,city,job</span>):</span></span><br><span class="line">  print(name,age,city,job)    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(name = <span class="string">&quot;blayt&quot;</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>) <span class="comment">#Error!</span></span><br><span class="line">SyntaxError: positional argument follows keyword argument</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>) <span class="comment">#Correct!</span></span><br><span class="line"><span class="number">12</span> <span class="number">12</span> <span class="number">12</span> <span class="number">12</span></span><br></pre></td></tr></table></figure></li>
<li><p>要求至少有一个参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">pre,*x</span>):</span></span><br><span class="line">    sum = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">        sum = sum * i</span><br><span class="line">    <span class="keyword">return</span> pre * sum</span><br><span class="line"><span class="comment">#无参数调用时会报错</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 4635 Strongly connected</title>
    <url>/2018/07/25/Strongly%20connected/</url>
    <content><![CDATA[<h2 id="题目大意">题目大意</h2>
<p>给你一个简单有向图(无重边、自环)，问最多加上多少条边，使它是一个非强连通的有向图</p>
<p>如果原图是强联通图，输出-1</p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>极其妙的题</p>
<p>最先想将每个SCC成完全图,然后找一个最小的SCC，将它向其它的点都连一条边,最后，非最小SCC互相连接</p>
<p>然后然后简化简化</p>
<p>发现第一步和第三步就是将除最小SCC外的点连成完全图</p>
<p>最后就是</p>
<ul>
<li>强连通缩点，并找出最小的SCC，大小记为<span class="math inline">\(mi\)</span></li>
<li>将最小的SCC向其它点都连一条边，一共要连<span class="math inline">\(mi * (n - mi)\)</span>条边</li>
<li>除最小SCC外的点连成完全图，要连<span class="math inline">\((n - mi) * (n - mi - 1)\)</span>条边</li>
<li>也可以看做将原图连成完全图，在删去最小SCC上全连出或连入的边</li>
<li>减去原来图中的边，答案即为$(n - mi) * (n - mi - 1) + mi * (n - mi) - m \ = n * (n - 1) - mi * (n - mi) - m $</li>
<li>好像是对的，恩</li>
</ul>
<p><code>waaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!</code></p>
<p>我们来考虑这样一个缩点后的图 <del>待更</del></p>
<p>可以发现，在整个图变为完全图后(再加一张图)，无论在<span class="math inline">\(mi\)</span>(即一个出度、入度均不为0的SCC)上怎么删边(当然，<strong>原图中的边是不能删的</strong>)，原图始终是强联的</p>
<p>且<span class="math inline">\(mi\)</span>最小不一定<span class="math inline">\(mi * (n - mi)\)</span>最小</p>
<p>所以我们要删边的SCC一定是入度或出度为0的(<del>显然</del>),且<span class="math inline">\(mi * (n - mi)\)</span>最小</p>
<h2 id="code"><code>Code</code></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可看做n个点全部构成完全图，再减去一个其它点连向一个scc的有向边（一条）和原图中的边</span></span><br><span class="line"><span class="comment">//这个SCC必须是入度或出度为0!!否则删了过后还是强连通！！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,idx,cnt,k,top,head[MAXN],dfn[MAXN],low[MAXN],st[MAXN];</span><br><span class="line"><span class="keyword">int</span> bel[MAXN],sz[MAXN],in[MAXN],out[MAXN];</span><br><span class="line"><span class="keyword">bool</span> ins[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,nxt;&#125;e[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   e[++k].v = v;</span><br><span class="line"> e[k].nxt = head[u],head[u] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v;dfn[u] = low[u] = ++idx;ins[st[++top] = u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">  &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v = e[i].v]) tarjan(v),low[u] = Min(low[u],low[v]);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(ins[v] &amp;&amp; dfn[v] &lt; low[u]) low[u] = dfn[v];</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u])</span><br><span class="line"> &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">       &#123;</span><br><span class="line">            ins[v = st[top]] = <span class="number">0</span>,bel[v] = cnt;</span><br><span class="line">            ++sz[cnt];</span><br><span class="line">        &#125;<span class="keyword">while</span>(st[top--] != u);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,m,u,v,ca(<span class="number">0</span>);ll ans,t;</span><br><span class="line">  read(T);</span><br><span class="line">  <span class="keyword">while</span>(T--)</span><br><span class="line">   &#123;</span><br><span class="line">        idx = cnt = top = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line">     <span class="built_in">memset</span>(head,k = <span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">       <span class="built_in">memset</span>(sz,<span class="number">0</span>,<span class="keyword">sizeof</span>(sz));</span><br><span class="line">       <span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="keyword">sizeof</span>(in));</span><br><span class="line">       <span class="built_in">memset</span>(out,<span class="number">0</span>,<span class="keyword">sizeof</span>(out));</span><br><span class="line">     read(n),read(m);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= m;i++)</span><br><span class="line">         read(u),read(v),add_edge(u,v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++)</span><br><span class="line">         <span class="keyword">if</span>(!dfn[i]) tarjan(i);</span><br><span class="line">       <span class="keyword">if</span>(cnt &lt;= <span class="number">1</span>) ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">            <span class="keyword">for</span>(u = <span class="number">1</span>;u &lt;= n;u++)</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">                  <span class="keyword">if</span>(bel[u] != bel[e[i].v]) ++out[bel[u]],++in[bel[e[i].v]];</span><br><span class="line">           </span><br><span class="line">          ans = -m + <span class="number">1l</span>l * n * (n - <span class="number">1</span>),t = (<span class="number">1l</span>l &lt;&lt; <span class="number">40</span>);</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= cnt;i++)</span><br><span class="line">               <span class="keyword">if</span>((!out[i] || !in[i]) &amp;&amp; sz[i] * (n - sz[i]) &lt; t) t = sz[i] * (n - sz[i]);</span><br><span class="line">           ans -= t;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %lld\n&quot;</span>,++ca,ans);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder AGC 026 B-rng_10s</title>
    <url>/2018/10/23/agc026B/</url>
    <content><![CDATA[<h2 id="题目大意">题目大意</h2>
<p>一家店有<span class="math inline">\(A\)</span>瓶果汁，每天白天会有一个人来买<span class="math inline">\(B\)</span>瓶果汁，晚上如果该店果汁不大于<span class="math inline">\(C\)</span>瓶则会进货<span class="math inline">\(D\)</span>瓶，求这个人是否能一直在该店买果汁。</p>
<p><span class="math inline">\(1 \leq A,B,C,D \leq 10^{18}\)</span></p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p>玄学数论。。。。。</p>
<p>官方题解在<a href="https://agc026.contest.atcoder.jp/editorial">这儿</a>,大意相同的中文题解在<a href="www.bing.com">这儿</a>。表示没看懂。。。<a href="https://blog.csdn.net/qq_34454069/article/details/81055250">这</a>是一个比较好懂的题解</p>
<p>先考虑特殊情况：<span class="math inline">\(A \lt B\)</span> 和 <span class="math inline">\(D \lt B\)</span> 是一定是不可能的。</p>
<p>此外，<del>通过找规律</del>，我们发现当当前果汁数<span class="math inline">\(\in(C,B)\)</span>时，这个人就买不到果汁了。</p>
<p>因此，<span class="math inline">\((C,B) \to [C+1，B-1]\)</span>，即<span class="math inline">\(C+1 \gt B-1 \to C \gt B-2\)</span> 时，这个人一直都能买到果汁</p>
<p>现在考虑一般情况，无非就是看这一个式子有不有一对整数解</p>
<p><span class="math display">\[C \lt A - x \times B + y \times D \lt B\]</span></p>
<p>变形</p>
<p><span class="math display">\[A - B \lt x \times B - y \times D \lt A - C\]</span></p>
<p>看到中间那一堆想到了啥？<strong>斐蜀定理</strong>（<span class="math inline">\(ax+by=gcd(a,b)\)</span>恒有整数解）</p>
<p>因此只要看看<span class="math inline">\((A-B,A-C)\)</span>中是否存在<span class="math inline">\(gcd(B,D)\)</span>的因数就可以了。</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/priority_queue.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T ret(0),f(1);char ch(getchar());</span><br><span class="line"> <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line"> <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = ret * <span class="number">10</span> + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> y ? gcd(y,x % y) : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> T;ll a,b,c,d,g;</span><br><span class="line">  read(T);</span><br><span class="line">  <span class="keyword">while</span>(T--)</span><br><span class="line">   &#123;</span><br><span class="line">        read(a),read(b),read(c),read(d);</span><br><span class="line">      <span class="keyword">if</span>(a &lt; b || b &gt; d) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(c &gt; b - <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">            g = gcd(b,d);</span><br><span class="line">         <span class="keyword">if</span>((a - b) / g &gt;= (a - c - <span class="number">1</span>) / g) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);<span class="comment">//-1?</span></span><br><span class="line">         <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>多彩的巧克力</title>
    <url>/2018/08/27/colorful%20chocolate/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>奶牛 <span class="math inline">\(Bessie\)</span>有<span class="math inline">\(N\)</span>块巧克力，从左往右排成一行，编号从<span class="math inline">\(0\)</span>到<span class="math inline">\(N-1\)</span>。第<span class="math inline">\(i\)</span>块巧克力的颜色是<span class="math inline">\(color_i\)</span>。我们定义一个参数 <span class="math inline">\(MaxLen\)</span>,它表示：具有相同颜色的连续一段巧克力的最大长度。例如：有 <span class="math inline">\(10\)</span>块巧克力，颜色分别是:<code>ADDDABBAAB</code>,那么<span class="math inline">\(MaxLen=3\)</span>,因为有<span class="math inline">\(3\)</span>块颜色是<span class="math inline">\(D\)</span>的巧克力，而且这<span class="math inline">\(3\)</span>块巧克力的位置是连续的。为了使得<span class="math inline">\(MaxLen\)</span>最大，<span class="math inline">\(Bessie\)</span>可以交换相邻两块巧克力的位置，但是<span class="math inline">\(Bessie\)</span>总共交换的次数不能超过给定的值<span class="math inline">\(swap\)</span>。那么<span class="math inline">\(MaxLen\)</span>的最大值是多少？</p>
<p><span class="math inline">\(1 \leq n \leq 50 \ , \ 1 \leq swap \leq 2500\)</span></p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p>考试时想复杂了，写了一大堆，占了2个多小时，最后还错了一个点。。。</p>
<p><strong>所以说不要想复杂了！！！</strong></p>
<p>其实这题思路很简单，由于把相同的巧克力从两边向中间移动所消耗的步数是最少的，所以以枚举中点，模拟从两边拉巧克力过来（每次拉离当前区间最近的），并保证总步数小于<span class="math inline">\(swap\)</span>，最后更新以当前点扩展的相同巧克力区间即可</p>
<p>每次用完了步数就更新答案。时间复杂度大概是<span class="math inline">\(O(n^2)\)</span></p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 55</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   T ret(0),f(1);char ch(getchar());</span><br><span class="line"> <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line"> <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = ret * <span class="number">10</span> + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x : y;&#125;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> T,n,sw,ans,l,r,j,k,temp;</span><br><span class="line"> read(T);</span><br><span class="line">  <span class="keyword">while</span>(T--)</span><br><span class="line">   &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">      read(n),read(sw);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">            l = r = i,j = i - <span class="number">1</span>,k = i + <span class="number">1</span>,temp = sw;</span><br><span class="line">          <span class="keyword">while</span>(j &gt;= <span class="number">1</span> || k &lt;= n)<span class="comment">//只要一边满足条件即可</span></span><br><span class="line">           &#123;</span><br><span class="line">                <span class="keyword">while</span>(j &gt;= <span class="number">1</span> &amp;&amp; s[j] != s[i]) --j;<span class="comment">//寻找左右相同颜色</span></span><br><span class="line">             <span class="keyword">while</span>(k &lt;= n &amp;&amp; s[k] != s[i]) ++k;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= <span class="number">1</span> &amp;&amp; (l - j &lt;= k - r || k &gt; n))</span><br><span class="line">                 <span class="keyword">if</span>(temp - (l - j - <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> temp -= l - j - <span class="number">1</span>,--l,--j;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(k &lt;= n &amp;&amp; (l - j &gt; k - r || j &lt; <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">if</span>(temp - (k - r - <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> temp -= k - r - <span class="number">1</span>,++r,++k;</span><br><span class="line">          &#125;</span><br><span class="line">            ans = Max(ans,r - l + <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C++引用</title>
    <url>/2018/08/15/cpp_reference/</url>
    <content><![CDATA[<blockquote>
<p>大家在使用引用和指针时，只要记住一点就够了，在c++底层中，引用是通过指针实现的，所以，在实现层面上来说，引用就是指针，但是在c++语法上来说，c++编译器并不为引用类型分配内存，所以引用不能为空，必须被初始化，一旦初始化不能更改引用对象。所有对引用的操作都是对原始对象的操作 -- 静远1175</p>
</blockquote>
<a id="more"></a>
<h2 id="定义">定义</h2>
<p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字，所以编译器不会为引用单独分配内存空间。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>
<p>底层上，引用是由指针实现的</p>
<p>你比如说，提到“红太阳”的时候，我们都知道是<a href="https://tgsteven.github.io/">TGSteven</a>。也就可以说，“红太阳”是TGSteven的一个引用。</p>
<p><del>还有一些暴力的例子，在这儿就不举了</del></p>
<h2 id="实现">实现</h2>
<p>一个<code>int</code>类型的引用</p>
<p>注意：<strong>引用必须初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> &amp;a;<span class="comment">//错的！</span></span><br><span class="line"><span class="keyword">int</span>&amp; a = t;<span class="comment">//a为t的一个引用</span></span><br><span class="line">a = <span class="number">3</span>;<span class="comment">//等效于t = 3</span></span><br></pre></td></tr></table></figure>
<h2 id="应用">应用</h2>
<ul>
<li>一般可以用来减少代码长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; ans = dp[...][...];</span><br></pre></td></tr></table></figure>
<ul>
<li>函数传入的参数的改变要对应到原值时</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b,b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于引用的声明不会增添空间开销，故作为函数形参时速度较快。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a,<span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项">注意事项</h2>
<ol type="1">
<li>引用目标一旦确定，<strong>后面不能更换，只能初始化</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">int a(2),b(3);</span><br><span class="line"><span class="keyword">int</span>&amp;t = a;</span><br><span class="line">t = b;<span class="comment">//等效于a = b,并不是将t的引用目标由b转向a</span></span><br></pre></td></tr></table></figure>
<p>作死实例：<a href="https://loj.ac/submissions?contest=&amp;problem_id=6281&amp;submitter=PrimeMinister&amp;min_score=0&amp;max_score=100&amp;language=&amp;status=">LOJ 6281</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> f;</span><br><span class="line">  ll&amp; L(sum[bel[l]]),R(sum[bel[r]]);//here</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">ed</span><span class="params">(Min(bel[l] * size,r))</span></span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i(l);i &lt;= ed;i++) L -= a[i],a[i] = <span class="built_in">sqrt</span>(a[i]),L += a[i];</span><br><span class="line">   <span class="keyword">if</span>(bel[l] != bel[r])</span><br><span class="line"> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i((bel[r] - <span class="number">1</span>) * size + <span class="number">1</span>);i &lt;= r;i++)</span><br><span class="line">           R -= a[i],a[i] = <span class="built_in">sqrt</span>(a[i]),R += a[i];</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(bel[l] + <span class="number">1</span>);i &lt; bel[r];i++)<span class="comment">//玄妙的暴力</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i]) <span class="keyword">continue</span>;</span><br><span class="line">       f = <span class="number">1</span>,ed = i * size,L = sum[i];<span class="comment">//and here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j((i - <span class="number">1</span>) * size + <span class="number">1</span>);j &lt;= ed;j++)</span><br><span class="line">       &#123;</span><br><span class="line">            L -= a[j],a[j] = <span class="built_in">sqrt</span>(a[j]),L += a[j];</span><br><span class="line">          <span class="keyword">if</span>(a[j] &gt; <span class="number">1</span>) f = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        flag[i] = f;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//wa!</span></span><br></pre></td></tr></table></figure>
<p>2.声明引用时，不能 <code>int&amp; a=xxx,b=xxx</code>,要分开写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; a = xxx;<span class="keyword">int</span>&amp; b = xxx;</span><br></pre></td></tr></table></figure>
<p>3.没有引用数组</p>
<h2 id="参考资料">参考资料</h2>
<blockquote>
<p>https://blog.csdn.net/tianxiaolu1175/article/details/46889523<br> http://www.runoob.com/cplusplus/cpp-references.html<br> https://blog.csdn.net/feitianxuxue/article/details/7204116</p>
</blockquote>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>C++语法相关</tag>
      </tags>
  </entry>
  <entry>
    <title>没有标题</title>
    <url>/2018/09/04/dairy1/</url>
    <content><![CDATA[<center>
<h1 id="你学习的动机是什么">你学习的动机是什么？</h1>
</center>
<a id="more"></a>
<p>其实，学习的动机并不重要，只要有一个能使你拼了命学的动机就行了，管他妈这个动机是什么。</p>
<p>无论这个动机是多么崇高，多么伟大，只要不能使你努力学习，就是放炮。</p>
<p>无论这个动机是多么下流，肮脏，无耻，只要能使你拼命学，就是好的。</p>
<p>毕竟很少有人会问你你学习动机是啥，他们只关心你是怎么学好的。</p>
<p>就算问你，编一个也行。</p>
<p>再次声明，<strong>人是一种非常、非常奇怪的生物</strong>。</p>
<p>2018/9/4,离死亡还有68天。</p>
<p>距离<span class="math inline">\({\rm Project A/Z}\)</span>结束已经过去了464天</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>华丽的吊灯</title>
    <url>/2018/08/07/lamp/</url>
    <content><![CDATA[<h2 id="题面">题面</h2>
<h3 id="背景描述">背景描述</h3>
<p>著名的 Microhardware 公司即将迎来其创业 50 周年庆典，为了使这次庆典能够体面而 又隆重，以显出公司在国际硬件的龙头地位，总裁决定举办一次交谊舞会，届时将有社会 各界名流前来捧场，希望以此来提高本公司的名望。他将布置场地的任务交给了JYY，而 JYY 遇到了一个小小的问题——吊灯。 <a id="more"></a></p>
<h3 id="问题描述">问题描述</h3>
<p>在当前的经济环境下，JYY 为了省钱，从一个不知名的小吊灯商那里购来一批吊灯， 但是他发现并不能直接把这吊灯挂起来：只有一个吊灯能挂在天花板上，而其他所有的灯 只能固定的挂在某一个别的吊灯上（可恶的奸商～…好在没有什么吊灯 A 只能挂在吊灯 B 上，而吊灯 B 却也只能挂在吊灯 A 上）。众所周知，每个吊灯都有其本身的重量，也有一 定的承受能力（如果某一个下面吊的东西太多的话，那么 Microhardware 公司就得给舞者 准备保险金和医疗金了），并且，不是所有的吊灯亮度都一样的。JYY 希望能够选出其中 的一些吊灯吊起来，每个灯下面所吊的都在其重力承受范围之内，且使所有灯的亮度之和 最大，JYY 要求你帮他解决这个问题（我不保证他会给你工钱，但是如果你不做的就会被 公司解雇）。</p>
<h3 id="输入描述">输入描述</h3>
<p>输入文件共包含 <span class="math inline">\(n+1\)</span> 行： 第一行一个整数 <span class="math inline">\(n\)</span>。以后的 n 行每行四个整数 <span class="math inline">\(t\)</span>、<span class="math inline">\(w\)</span>、<span class="math inline">\(p\)</span>、<span class="math inline">\(l\)</span>，第 <span class="math inline">\(i+1\)</span> 行的 <span class="math inline">\(t\)</span> 表示第 <span class="math inline">\(i\)</span> 盏灯 只能吊在第 <span class="math inline">\(t\)</span> 盏灯下面，<span class="math inline">\(w\)</span> 表示第 <span class="math inline">\(i\)</span> 盏灯的重量，<span class="math inline">\(p\)</span> 表示第 <span class="math inline">\(i\)</span> 盏灯所能吊起的最大重力,<span class="math inline">\(l\)</span> 表 示第 <span class="math inline">\(i\)</span> 盏灯的亮度。 注意：第 <span class="math inline">\(1\)</span> 盏灯的 <span class="math inline">\(t=0\)</span>。</p>
<h3 id="输出描述">输出描述</h3>
<p>输出文件共包含 1 行： 第一行两个整数 <span class="math inline">\(m,maxl,m\)</span>为所选中的吊灯的数量，<span class="math inline">\(maxl\)</span> 为最大的亮度。</p>
<h2 id="solution">Solution</h2>
<ul>
<li><a href="http://codevs.cn/problem/1521/">Codevs1512</a></li>
<li>该题作为考试题时并没有要求输出方案</li>
<li>巧妙的树上背包</li>
<li>令<span class="math inline">\(dp[u][i]\)</span>为以<span class="math inline">\(u\)</span>为根节点的子树载重量（不包括自己）为<span class="math inline">\(i\)</span>时能得到的最大亮度,<span class="math inline">\(v\)</span>为<span class="math inline">\(u\)</span>的儿子,<span class="math inline">\(j\)</span>为<span class="math inline">\(v\)</span>这颗子树的重量</li>
<li>那么就有 <span class="math display">\[ dp[u][i] = \max(dp[u][i - j - w[j]] + dp[v][j] + l[j])\]</span></li>
<li>吊灯数量的话，用<span class="math inline">\(num[u][i]\)</span>（<span class="math inline">\(u\)</span>,<span class="math inline">\(i\)</span>同上）表示，当<span class="math inline">\(dp[u][i]\)</span>更新时,则有 <span class="math display">\[num[u][i] = num[u][i - j - w[j]] + num[v][j] + 1\]</span></li>
<li>+1是因为选上了<span class="math inline">\(v\)</span></li>
<li>最终答案记得加上根节点</li>
</ul>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 405</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T ret(0),f(1);char ch(getchar());</span><br><span class="line"> <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line"> <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line"> a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k,head[MAXN],dp[MAXN][<span class="number">205</span>],num[MAXN][<span class="number">205</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lamp</span>&#123;</span><span class="keyword">int</span> w,p,l;&#125;a[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,nxt;&#125;e[MAXN &lt;&lt; <span class="number">1</span> | <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   e[++k].v = v;</span><br><span class="line"> e[k].nxt = head[u],head[u] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> v;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">  &#123;</span><br><span class="line">        <span class="keyword">if</span>((v = e[i].v) == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,u);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i(a[u].p);i &gt;= a[v].w;i--)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>);j &lt;= a[v].p &amp;&amp; i &gt;= j + a[v].w;j++)<span class="comment">//以v为根的子树的重量 (不包含v)</span></span><br><span class="line">          &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[u][i] &lt; dp[u][i - j - a[v].w] + dp[v][j] + a[v].l)</span><br><span class="line">              &#123;</span><br><span class="line">                    dp[u][i] = dp[u][i - j - a[v].w] + dp[v][j] + a[v].l;</span><br><span class="line">                 num[u][i] = num[u][i - j - a[v].w] + num[v][j] + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;lamp.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">   freopen(<span class="string">&quot;lamp.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line"> <span class="keyword">int</span> n,v,mx(<span class="number">-1</span>),nm;</span><br><span class="line">   read(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++)</span><br><span class="line"> &#123;</span><br><span class="line">        read(v),read(a[i].w),read(a[i].p),read(a[i].l);</span><br><span class="line">       <span class="keyword">if</span>(v) add_edge(v,i),add_edge(i,v);</span><br><span class="line">   &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i &lt;= a[<span class="number">1</span>].p;i++)<span class="comment">//a[1].p!!!</span></span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">1</span>][i] &gt; mx) mx = dp[<span class="number">1</span>][i],nm = num[<span class="number">1</span>][i];</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,nm + <span class="number">1</span>,mx + a[<span class="number">1</span>].l);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>中位数?</title>
    <url>/2018/08/23/median%20interval/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>有一个长度为 <span class="math inline">\(N\)</span> 的数列<span class="math inline">\(\{A_1,A_2,...,A_n \}\)</span>，这 <span class="math inline">\(N\)</span> 个数字恰好是 <span class="math inline">\([1,n]\)</span> 的一个排列。你需要统计有多少个子序列<span class="math inline">\(\{A_i,A_{i+1},...,A_j \}\)</span>满足：<span class="math inline">\(i \le j\)</span> 且 <span class="math inline">\(j-i+1\)</span> 为奇数，序列的中位数为 <span class="math inline">\(B\)</span>。例如<span class="math inline">\(\{5,1,3 \}\)</span>的中位数为 <span class="math inline">\(3\)</span>。</p>
<p><span class="math inline">\(1 \le N \le 10^5\)</span></p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p>尺取法（或者叫双指针）必须要考虑的条件是左指针和右指针什么时候该移动，区间满足什么性质</p>
<p>然后，这题根本不知道左右指针怎么移动，故不可能用尺取法做。</p>
<p>既然<span class="math inline">\(B\)</span>是中位数，那么其区间里大于它和小于它的数字的个数是相等的</p>
<p>我们把大于<span class="math inline">\(B\)</span>的数字标记为<span class="math inline">\(1\)</span>,小于<span class="math inline">\(B\)</span>的数字标记为<span class="math inline">\(-1\)</span>,<span class="math inline">\(B\)</span>则标记为<span class="math inline">\(0\)</span>,如上述条件成立，则这个区间里必须有一个<span class="math inline">\(0\)</span>，且标记和为<span class="math inline">\(0\)</span></p>
<p>暴力<span class="math inline">\(O(n^2)\)</span>找显然是不可能的</p>
<p>在前缀和中，如区间<span class="math inline">\([l,r]\)</span>的和为<span class="math inline">\(0\)</span>，则<span class="math inline">\(sum[l - 1] = sum[r]\)</span></p>
<p>所以，只要记录包含<span class="math inline">\(0\)</span>的区间<span class="math inline">\(sum[l - 1] = sum[r]\)</span>有几种就可以了,方法见代码</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN],cnt[MAXN &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];<span class="comment">//记录和为i的方案有多少种</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,mid,pos,t,ans(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;mid);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a + i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++)</span><br><span class="line">     <span class="keyword">if</span>(a[i] == mid) pos = i,a[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> a[i] = (a[i] &gt; mid) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i &lt; pos;i++)<span class="comment">//0 = 1 - 1(l - 1)</span></span><br><span class="line">     t += a[i],++cnt[t + MAXN];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(pos);i &lt;= n;i++)</span><br><span class="line">       t += a[i],ans += cnt[t + MAXN];</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title>斯诺克-玄学台球</title>
    <url>/2018/08/25/mogic_snoke/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>Да здравствует советский！</p>
<p>考虑这样一个<span class="math inline">\(n \times m\)</span>的斯诺克球台，它只有四个袋口，分别在四个角上（如下图所示）。我们把所有桌子边界上的整数点作为击球点（除了 4 个袋口），在每个击球点我们可以以 <span class="math inline">\(45\)</span>度角击球。</p>
<figure>
<img src="https://img-blog.csdn.net/20170620192715287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS3NDbGE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="1" /><figcaption aria-hidden="true">1</figcaption>
</figure>
<p>每一个击球点你都可以向两个方向击球，例如像下图所示，从S点击球有两种路线。提供桌子的尺寸，你的任务是计算出有多少种不同的击球方式使得球能入袋。球可为质点，且无任何阻力，反弹时无能量损失</p>
<p><span class="math inline">\(1 \leq n \leq 100000 \ , \ 1 \leq m \leq 100000\)</span></p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p>玄学模拟题，当然也可以找规律</p>
<p>如果我们枚举每个非顶点的点向不同方向打去，妥妥地TLE</p>
<p><strong>正难则反</strong>，考虑从每个顶点开始模拟，直到走到另一个顶点，到的每一个点都是可以到这个顶点的，而且路径不会有重复的点（有重复的点说明有一个环，就没法射进洞）。所以到这个顶点的方案数就是经过的点数</p>
<p>由对称性得，每个顶点的方案数都是一样的，所以只需算出一个点的方案数<span class="math inline">\(\times 4\)</span>就可以了</p>
<p>注意在模拟反弹时情况考虑对</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> x,y,d;&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m;ll ans;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)|| (x == <span class="number">0</span> &amp;&amp; y == m) || (x == n &amp;&amp; y == <span class="number">0</span>) || (x == n &amp;&amp; y == m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//球只能从一个方向弹出。。。。</span></span><br><span class="line"><span class="comment">//t.d 来的方向 0 左上 1 右上 2 右下 3 左下</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Advance</span><span class="params">(node&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = t.x,y = t.y,td = t.d;</span><br><span class="line">    <span class="comment">//printf(&quot;%d %d\n&quot;,x,y);</span></span><br><span class="line">   <span class="keyword">if</span>(check(x,y)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(td == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">            t.d = <span class="number">3</span>;</span><br><span class="line">          <span class="keyword">if</span>(y &gt;= n) t.x = n,t.y = y - n;</span><br><span class="line">           <span class="keyword">else</span> t.x = y,t.y = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         t.d = <span class="number">1</span>,t.x = <span class="number">0</span>,t.y = x;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(td == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">            t.d = <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span>(m - y &gt;= n) t.x = n,t.y = y + n;</span><br><span class="line">           <span class="keyword">else</span> t.x = m - y,t.y = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> t.d = <span class="number">0</span>,t.x = <span class="number">0</span>,t.y = m - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(td == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n)</span><br><span class="line">       &#123;</span><br><span class="line">            t.d = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(m - y &gt;= n) t.x = <span class="number">0</span>,t.y = y + n;</span><br><span class="line">           <span class="keyword">else</span> t.x = n + y - m,t.y = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> t.d = <span class="number">3</span>,t.x = n,t.y = x + m - n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n)</span><br><span class="line">       &#123;</span><br><span class="line">            t.d = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>(y &gt;= n) t.x = <span class="number">0</span>,t.y = y - n;</span><br><span class="line">           <span class="keyword">else</span> t.x = x - y,t.y = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> t.d = <span class="number">2</span>,t.x = n,t.y = n - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">  <span class="keyword">if</span>(n == m) ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; n) swap(n,m);</span><br><span class="line">      node t;<span class="comment">//用模拟行走代替深搜，简化代码</span></span><br><span class="line">      t.x = n,t.y = n,t.d = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span>(Advance(t)) </span><br><span class="line">           ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Palin</title>
    <url>/2018/08/21/palin/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>大家都知道回文串吧！简单地说就是左右对称的一个串，比如 <code>abcba</code>,<code>werrew</code>。小 s 对回文串的研究已经够深刻了，现在她转而研究其他方面的回文，比如，数的回文拆分。</p>
<p>对于自然数的拆分，就是把一个自然数 <span class="math inline">\(N\)</span> 用若干个整数之和表示。比如 <span class="math inline">\(15 = 1+2+3+4+5 = 1+2+1+7+1+2+1\)</span>。</p>
<p>那么怎样的拆分才算是回文的呢？我们用从归纳的角度来定义数的回文拆分。首先一个数 <span class="math inline">\(A = A\)</span> 是一个回文拆分。其次，一个自然数 <span class="math inline">\(N=A+A\)</span> 或是 <span class="math inline">\(N=A+x+A\)</span>，其中 <span class="math inline">\(A\)</span> 是一个回文拆分，<span class="math inline">\(x\)</span> 是任意一个自然数，这两种也是回文拆分。举个例子，7 的所有回文拆分有 <span class="math inline">\(7,\ 1+5+1,\ 2+3+2,\ 1+1+3+1+1,\ 3+1+3,\ 1+1+1+1+1+1+1\)</span>，而<span class="math inline">\(1+2+1+2+1\)</span>不是（<span class="math inline">\(1 + 2\)</span>不是一个回文拆分）。</p>
<p>现在小 s 想知道，一个正整数 <span class="math inline">\(N\)</span> 的回文拆分到底有多少种。由于这个数字可能很大，小 s 只需要你告诉她答案 mod <span class="math inline">\(1,000,000,007\)</span>的值 <a id="more"></a></p>
<h2 id="输入">输入</h2>
<p>一行，一个正整数 <span class="math inline">\(N\)</span>。</p>
<h2 id="输出">输出</h2>
<p>一行，一个整数 <span class="math inline">\(M\)</span>，为 <span class="math inline">\(N\)</span> 的回文拆分数 mod <span class="math inline">\(1,000,000,007\)</span> 的值</p>
<h2 id="数据范围">数据范围</h2>
<p><span class="math inline">\(1 \leq n \leq 10^5\)</span></p>
<h2 id="solution">Solution</h2>
<p><span class="math inline">\(N = N \longrightarrow N = 0 + N + n\)</span></p>
<p><span class="math inline">\(N = A + A \longrightarrow N = A + 0 + A\)</span></p>
<p>于是乎，所有的差分都可以表示为<span class="math inline">\(N = A + x + A\)</span>这种形式</p>
<p><span class="math inline">\(A\)</span>又是一个拆分数，且其最大值为<span class="math inline">\(\lfloor \frac{n}{2} \rfloor\)</span>,定义<span class="math inline">\(A_n\)</span>为<span class="math inline">\(n\)</span>这个数的拆分方案，则有： <span class="math display">\[A_n = \sum_{i = 1}^{\lfloor \frac{n}{2} \rfloor}A_i\]</span></p>
<p>直接这样记忆化搜索是会T掉的,所以要用到前缀和优化，令<span class="math inline">\(S_n = \sum_{i = 1} ^ {n}Ai\)</span>,则有 <span class="math display">\[S_n = S_{n - 1} + A_{n}\]</span></p>
<p><span class="math display">\[S_n= S_{n - 1} + S_{\lfloor \frac{n}{2} \rfloor}\]</span></p>
<p><span class="math inline">\(S_1 = A_1\)</span></p>
<p>直接递推，最后<span class="math inline">\(S_{\lfloor \frac{n}{2} \rfloor}\)</span>就是答案</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll dp[<span class="number">100005</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">/*inline ll dfs(int x)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  if(dp[x]) return dp[x];</span></span><br><span class="line"><span class="comment">  ll ret(1);</span></span><br><span class="line"><span class="comment">   for(int i(1);(i &lt;&lt; 1) &lt;= x;i++)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment">       ret += dfs(i);</span></span><br><span class="line"><span class="comment">       if(ret &gt; mod) ret -= mod;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">   return dp[x] = ret % mod;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   freopen(<span class="string">&quot;palin.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">&quot;palin.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">   n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++)</span><br><span class="line">     dp[i] = (dp[i - <span class="number">1</span>] + dp[i &gt;&gt; <span class="number">1</span>]) % mod;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,dp[n]);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>虫洞</title>
    <url>/2018/10/11/wornwhole/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="math inline">\(N\)</span>个虫洞，<span class="math inline">\(M\)</span>条单向跃迁路径。从一个虫洞沿跃迁路径到另一个虫洞需要消耗一定量的燃料和1单位时间。虫洞有白洞和黑洞之分。设一条跃迁路径两端的虫洞质量差为<span class="math inline">\(delta\)</span>。</p>
<p>1.从白洞跃迁到黑洞，消耗的燃料值减少<span class="math inline">\(delta\)</span>，若该条路径消耗的燃料值变为负数的话，取为0。</p>
<p>2.从黑洞跃迁到白洞，消耗的燃料值增加<span class="math inline">\(delta\)</span>。</p>
<p>3.路径两端均为黑洞或白洞，消耗的燃料值不变化。</p>
<p>作为压轴题，自然不会是如此简单的最短路问题，所以每过1单位时间黑洞变为白洞，白洞变为黑洞。在飞行过程中，可以选择在一个（当前？）虫洞<span class="math inline">\(i\)</span>停留1个单位时间，如果当前为白洞，则不消耗燃料，否则消耗<span class="math inline">\(s_i\)</span>的燃料。现在请你求出从虫洞<span class="math inline">\(1\)</span>到<span class="math inline">\(N\)</span>最少的燃料消耗，保证一定存在<span class="math inline">\(1\)</span>到<span class="math inline">\(N\)</span>的路线。</p>
<p><span class="math inline">\(1 \leq N \leq 5000，1 \leq M \leq 30000\)</span></p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p><em>最短路相关的题目搞法无非就两种：松弛操作/转移的时候处理（当然还有怎么跑的问题），或者在建图上下功夫，本题属于后者。</em></p>
<p>既然在做最短路时来满足题意实在是显得十分烦人，因此，我们可以考虑如何巧妙地建图</p>
<p>考虑用<span class="math inline">\(u\)</span>表示<span class="math inline">\(u\)</span>点为白洞，<span class="math inline">\(u + n\)</span>表示<span class="math inline">\(u\)</span>为黑洞</p>
<ul>
<li>在<span class="math inline">\(u\)</span>停留，在<span class="math inline">\(u\)</span>与<span class="math inline">\(u + n\)</span>之间加上边</li>
<li>与<span class="math inline">\(u\)</span>相连的点<span class="math inline">\(v\)</span>
<ul>
<li>如果与<span class="math inline">\(u\)</span>一开始颜色相同，则他们颜色永远不可能不相同，在<span class="math inline">\(u\)</span>和<span class="math inline">\(v + n\)</span>与<span class="math inline">\(u + n\)</span>与<span class="math inline">\(v\)</span>之间加上原长边（<strong>因为是当前的颜色，到<span class="math inline">\(v\)</span>时<span class="math inline">\(v\)</span>的颜色已经变了</strong>）</li>
<li>否则反之，按题意加边，注意上一行粗体字部分</li>
</ul></li>
</ul>
<p><del>多久再去把网络流看看</del></p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/priority_queue.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line"> <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line"> <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = ret * <span class="number">10</span> + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,nxt,w;&#125;e[<span class="number">300005</span>];</span><br><span class="line"><span class="keyword">int</span> n,k,head[MAXN],dis[MAXN],val[MAXN],s[MAXN],h[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> u,v;</span><br><span class="line"> __gnu_pbds::<span class="built_in">priority_queue</span>&lt;pii,greater&lt;pii&gt; &gt;q;</span><br><span class="line"> <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">if</span>(h[<span class="number">1</span>]) dis[<span class="number">1</span> + n] = <span class="number">0</span>,q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">1</span> + n));</span><br><span class="line">    <span class="keyword">else</span> dis[<span class="number">1</span>] = <span class="number">0</span>,q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        u = q.top().second,q.pop();</span><br><span class="line">       <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i(head[u]);i;i = e[i].nxt)</span><br><span class="line">          <span class="keyword">if</span>(dis[v = e[i].v] &gt; dis[u] + e[i].w)</span><br><span class="line">             dis[v] = dis[u] + e[i].w,q.push(<span class="built_in">make_pair</span>(dis[v],v));</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> min(dis[n],dis[n &lt;&lt; <span class="number">1</span>]);<span class="comment">//终点黑点还是白点无所谓</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> e[++k].v = v,e[k].w = w;</span><br><span class="line">  e[k].nxt = head[u],head[u] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Abs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   freopen(<span class="string">&quot;holes.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">&quot;holes.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">   read(n),read(m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++) read(h[i]);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++) read(val[i]);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++) read(s[i]);</span><br><span class="line"> <span class="keyword">int</span> u,v,w;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">        read(u),read(v),read(w);</span><br><span class="line">      <span class="comment">//注意，边是转移到下一个状态，所以if成立时要一边不加n</span></span><br><span class="line">        <span class="keyword">if</span>(h[u] == h[v])<span class="comment">//注意分情况讨论：颜色相同的点永远不可能颜色不相同</span></span><br><span class="line">          add_edge(u,v + n,w),add_edge(u + n,v,w);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         add_edge(u,v,Max(w - Abs(val[v] - val[u]),<span class="number">0</span>)),add_edge(u + n,v + n,w + Abs(val[v] - val[u]));</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++)<span class="comment">//单独拿出来加：避免重边</span></span><br><span class="line">       add_edge(i,i + n,<span class="number">0</span>),add_edge(i + n,i,s[i]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dijkstra());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>区间平均值</title>
    <url>/2018/08/28/%E5%8C%BA%E9%97%B4%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>有<span class="math inline">\(N\)</span>个数，随机选择一段区间，如果这段区间的所有数的平均值<span class="math inline">\(val\in [l,r]\)</span>中则你比较厉害。求你比较厉害的概率。</p>
<p>输出一行一个分数<span class="math inline">\(a/b\)</span>代表答案，其中 <span class="math inline">\(a, b\)</span> 互质。 如果答案为整数则直接输出该整数即可</p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p><strong>认真看题！！！</strong>考试时看成了求平均值为<span class="math inline">\(a_i,i \in [l,r]\)</span>。。。。。</p>
<p><em>做不起的题可以根据题意设一个式子，或许会有意想不到的收获</em></p>
<p>首先，一共有<span class="math inline">\(\frac{n \times (n + 1)}{2}\)</span>个区间（ex：长度为<span class="math inline">\(n\)</span>的区间有<span class="math inline">\(1\)</span>个，长度为<span class="math inline">\(n - 1\)</span>的区间有<span class="math inline">\(2\)</span>个，。。。）。题目要求的区间个数可转化为<span class="math inline">\(val \in [1,r]\)</span>的区间个数减去<span class="math inline">\(val \in [1,l)\)</span>的区间个数（注意<span class="math inline">\(l\)</span>这儿是开区间）</p>
<p>先来看看怎么求<span class="math inline">\(val \in [1,r]\)</span>的区间。设区间起始位置为<span class="math inline">\(x\)</span>,,长度为<span class="math inline">\(k\)</span>，则有</p>
<p><span class="math display">\[\frac{a_x + a_{x + 1} + ... + a_{x + k - 1}}{k} \le r\]</span></p>
<p>两边同时乘以<span class="math inline">\(k\)</span></p>
<p><span class="math display">\[a_x + a_{x + 1} + ... + a_{x + k - 1} \le k \times r\]</span></p>
<p><span class="math display">\[a_x + a_{x + 1} + ... + a_{x + k - 1} - k \times r \le 0\]</span></p>
<p><span class="math display">\[(a_x - r) + (a_{x + 1} - r) + ... + (a_{x + k - 1} - r) \le 0\]</span></p>
<p>也就是求$ {a_i - r }$ 多少个区间和为<span class="math inline">\(0\)</span>，这样的问题我们可以转化为逆序对来求解</p>
<p>设<span class="math inline">\(S_n = \sum^{n}_{i = 1} (a_i - r)\)</span>，上述条件就变为：<span class="math inline">\(S_{i + k - 1} - S_{i - 1} \ \le 0 \ \to S_{i + k - 1} \le S_{i - 1}\)</span>，<span class="math inline">\(\because i - 1 \le i + k - 1\)</span>，这就是求逆序对的数量了（还要加上单个数（区间长度为<span class="math inline">\(1\)</span>）小于等于<span class="math inline">\(0\)</span>和前一个数等于后一个数的情况）</p>
<p>另一种情况同理，<strong>注意在求<span class="math inline">\(val \in [1,l)\)</span>的区间数量时，由于不能取<span class="math inline">\(l\)</span>（否则会剪掉正确答案）,就要去掉等号（eg：单个数要小于<span class="math inline">\(0\)</span>）</strong></p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/hash_policy.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   T ret(0),f(1);char ch(getchar());</span><br><span class="line"> <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line"> <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">2</span>) + ret,ret += ret + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">   a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125;</span><br><span class="line"><span class="keyword">int</span> n,cnt,a[MAXN],t[MAXN];ll ans[<span class="number">3</span>],s[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  merge_sort(l,mid,x),merge_sort(mid + <span class="number">1</span>,r,x);</span><br><span class="line">  int i(l),j(mid + 1),pos(l);</span><br><span class="line">   <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">  &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp;&amp; s[i] &gt;= s[j]) cnt += mid - i + <span class="number">1</span>,t[pos++] = s[j++];<span class="comment">//r.可以取相同的数</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(s[i] &gt; s[j]) cnt += mid - i + <span class="number">1</span>,t[pos++] = s[j++];</span><br><span class="line">       <span class="keyword">else</span> t[pos++] = s[i++];</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) t[pos++] = s[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) t[pos++] = s[j++];</span><br><span class="line">  <span class="keyword">for</span>(i = l;i &lt;= r;i++) s[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> x)</span><span class="comment">//左边要开区间：类似前缀和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++) </span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i] - val,ans[x] += (x == <span class="number">1</span> ? s[i] &lt; <span class="number">0</span> : s[i] &lt;= <span class="number">0</span>);<span class="comment">//考虑单个数（记得长度为1的区间）</span></span><br><span class="line">  merge_sort(<span class="number">1</span>,n,x == <span class="number">2</span>),ans[x] += cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//逆序对可以求区间和小于等于0的区间个数!!，巧妙</span></span><br><span class="line">   <span class="comment">//freopen(&quot;C.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"> <span class="comment">//freopen(&quot;C1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">  <span class="keyword">int</span> l,r;ll po,all(<span class="number">0</span>),g;</span><br><span class="line">  read(n),read(l),read(r),all = <span class="number">1l</span>l * (n + <span class="number">1</span>) * n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++) read(a[i]);</span><br><span class="line"> cal(l,<span class="number">1</span>),cal(r,<span class="number">2</span>),po = ans[<span class="number">2</span>] - ans[<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">if</span>(po == all) <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">   <span class="keyword">else</span> g = gcd(po,all),<span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,po / g,all / g);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
        <tag>分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title>春江花月夜</title>
    <url>/2018/11/13/%E6%98%A5%E6%B1%9F%E8%8A%B1%E6%9C%88%E5%A4%9C/</url>
    <content><![CDATA[<h4 align="right">
唐 张若虚
<h4>
<center>
春江潮水连海平，海上明月共潮生。<br> 滟滟随波千万里，何处春江无月明。<br> 江流宛转绕芳甸，月照花林皆似霰。<br> 空里流霜不觉飞，汀上白沙看不见。<br> 江天一色无纤尘，皎皎空中孤月轮。<br> 江畔何人初见月，江月何年初照人。<br> 人生代代无穷己，江月年年望相似。<br> 不知江月待何人，但见长江送流水。<br> 白云一片去悠悠，清风浦上不胜愁。<br> 谁家今夜扁舟子，何处相思明月楼。<br> 可怜楼上月徘徊，应找离人妆镜台。<br> 玉户帘中卷不去，捣衣砧上复还来。<br> 此时相望不相闻，愿逐月华流照君。<br> 鸿雁长飞光不度，鱼龙潜跃水成文。<br> 昨夜闲潭梦落花，可怜春半不还家。<br> 江水流春去欲尽，江潭月落复西斜。<br> 斜月沉沉藏海雾，碣石潇湘无限路。<br> 不知乘夜几人归，落月摇情满江树。<br>
</center>
<h4 align="right">
Oct,28th 2018
<h4>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>诗文词曲</tag>
      </tags>
  </entry>
  <entry>
    <title>打牌</title>
    <url>/2018/08/28/%E7%8E%84%E5%AD%A6%E6%89%93%E7%89%8C/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>现在玩打牌游戏，给你 <span class="math inline">\(n\)</span>张牌，每张牌上数字大小为<span class="math inline">\(x_i\)</span>，<strong>每张牌只能出一次</strong>，只可以出对子<span class="math inline">\((x,x)\)</span>或顺子<span class="math inline">\((x,x+1,x+2)\)</span>,问最多能组成多少个对子或顺子。</p>
<p><span class="math inline">\(1 \leq n \leq 1000000 \ , \ 1 \leq x_i \leq 1000000\)</span></p>
<a id="more"></a>
<h2 id="solution">Solution</h2>
<p>md我是怎么想到一张牌可以出多次的。。。。</p>
<p>首先，能出对子的话，就尽量出对子（<del>显然的贪心</del>）,剩下如果有连续的3个数字，就可以构成顺子</p>
<p>但再考虑一种特殊情况：<span class="math inline">\(1,2,3,3,4,5\)</span>，前面有两个单个数字的情况下，下一个对子可拆开，构成一个顺子。</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret(0),f(1);char ch(getchar());</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;ret = (ret &lt;&lt; <span class="number">2</span>) + ret,ret += ret + (ch ^ <span class="number">48</span>);ch = getchar();&#125;</span><br><span class="line">    a = ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> num,pos;&#125;b[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n,cnt(<span class="number">0</span>),sig(<span class="number">0</span>),ans(<span class="number">0</span>);<span class="comment">//不同数字的数量，单个数字</span></span><br><span class="line">   read(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++) read(a[i]);</span><br><span class="line"> sort(a + <span class="number">1</span>,a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= n;i++)</span><br><span class="line">     <span class="keyword">if</span>(a[i] != a[i - <span class="number">1</span>]) b[++cnt].num = <span class="number">1</span>,b[cnt].pos = i;</span><br><span class="line">        <span class="keyword">else</span> ++b[cnt].num;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= cnt;i++) ans += (b[i].num &gt;&gt; <span class="number">1</span>),b[i].num &amp;= <span class="number">1</span>;<span class="comment">//先出对子，保证最优</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i &lt;= cnt;i++)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i].num) <span class="comment">//抽完对子有剩下的</span></span><br><span class="line">     &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[b[i].pos] == a[b[i - <span class="number">1</span>].pos] + <span class="number">1</span>)</span><br><span class="line">               sig = (sig == <span class="number">2</span> ? ++ans,<span class="number">0</span> : sig + <span class="number">1</span>);<span class="comment">//当且仅当前面有两个连续的单个数字时</span></span><br><span class="line">         <span class="keyword">else</span> sig = <span class="number">1</span>;<span class="comment">//从头开始</span></span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[b[i].pos] == a[b[i - <span class="number">1</span>].pos] + <span class="number">1</span>)</span><br><span class="line">               sig = (sig == <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>);<span class="comment">//拆一个对子，答案加一个顺子，不变。 1 2 3 3 4 5</span></span><br><span class="line">         <span class="keyword">else</span> sig = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>随记</title>
    <url>/2020/07/23/%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>应 <span class="math inline">\({\rm Ada \pi}\)</span> 之邀而作，应该会印在毕业纪念册上</p>
</blockquote>
<blockquote>
<p><font face="Times New Roman" size = 5>"И снег, и ветер, И звёзд ночной полёт…</font><br> <font face="Times New Roman" size = 5>Меня мое сердце, В тревожную даль зовёт."</font></p>
</blockquote>
<a id="more"></a>
<p>霞光万丈。</p>
<p>高考截止铃声响起时，教学楼还是那样的寂静，此起彼伏的收卷声慢慢将过去浓缩、化简、提交、批阅后隐于尘埃之中。当一切完成以后，人群随着音乐慢慢的向出口移动――没有过于兴奋的吼声――自从初中以来就是这样了，大家都对考试的结束不再觉得有任何兴奋，只是想着快点回去，该享受享受，该准备下一次准备下一次。较昏暗的天空下，人流涌动，四处分散，不久，雨滴打在了车窗玻璃上。</p>
<p>最后一次考NOIP时，没有铃声，监考老师大喊着停止写代码之类的话，好丽友面包卷的包装和矿泉水瓶被扔进垃圾口袋，车上到处都是“您太强了”“xxx AK IOI”之类的话语。我呆望着窗外，时处十一月，树秃草枯，但不少人已经知道自己没法在来年四月看到它们再度繁茂了。</p>
<p>那天天气很好？反正我依稀记得是这样的，阳光透过车窗照在了椅子上。</p>
<p>在成外的竞赛生涯始于2017年6月30日的晚上，xyc习惯性将一杯水倒到门外，却忘了在门旁等着的我，所幸水不多。</p>
<p>同大多数竞赛生一样，我们盼望着晚自习的后两节，周末的竞赛时间。现在看着书柜里早已不用的竞赛书，OJ上做过的题，博客上写的题解和许些牢骚，都不由得感叹那是多么美好而充足的一段时光。算法的激烈讨论，考试时的紧张，讲题时的掌声，这些早已远去，遥不可及，却又像是发生在昨天。大多数人从机房走出，或许会在此回到机房，但不会是那个曾经举办过“联赛”的四号机房，抑或不会是四千元一台低配台式机的七号机房。最初的C++也会变成Python, Java, C#等。足以让隔壁机房听得一清二楚的笑声早已消散在空中，机房后写着毒奶的横幅也成了空白的一片墙壁，还留着许些当时的钉子。</p>
<p>今年欢笑复明年，不知退役在眼前。</p>
<p>不得不说信息学竞赛是此地五大学科竞赛中最没“人权”的竞赛，停课时间最短，不知何时起被剥夺了晚自习去机房的权利，没有集体外出培训，即使有少数人外出培训，生活条件相比其他竞赛也堪忧。这些或许可以解释一些在外人看来匪夷所思的东西，但都不重要了。</p>
<p>毕竟，我们笑过，我们迷茫过，我们奋斗过，我们来过。</p>
<p>多年以后，当我们从一行行代码、编译结果、程序文档上抬起头来时，将会想起初识LCA的那个遥远的上午，那时成外还没有二次装修，到处乱膜拜的风气还没有形成，yhtwd在激烈地与别人争论他的二分算法，阳光穿过蓝色窗帘照在键盘上。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>魏尔伦 秋之歌</title>
    <url>/2018/08/31/%E9%AD%8F%E5%B0%94%E4%BC%A6%20%E7%A7%8B%E4%B9%8B%E6%AD%8C/</url>
    <content><![CDATA[<center>
<p>秋之歌</p>
<p>保尔·魏尔伦 （Paul Verlaine）著</p>
<p>秋声悲鸣</p>
<p>犹如小提琴</p>
<p>在哭泣</p>
<a id="more"></a>
<p>悠长难耐的阴郁</p>
<p>刺痛了</p>
<p>我心脾。</p>
<p>沉沉闷闷</p>
<p>迷迷蒙蒙</p>
<p>钟声荡起</p>
<p>往事如烟</p>
<p>在眼前重现</p>
<p>我泪落如雨</p>
<p>我走了</p>
<p>恶风卷着我</p>
<p>东飘西零</p>
<p>飘呵，飘呵，</p>
<p>宛如那</p>
<p>枯叶飘零。</p>
</center>
<blockquote>
<p>Ré d’automne <br> Chanson d’automne <br> ----Paul Verlaine <br> <br> Les sanglots longs <br> Des violons <br> De l’automne <br> Blessent mon coeur <br> D’une langueur <br> Monotone. <br> <br> Tout suffocant <br> Et blême, quand <br> Sonne l’heure, <br> Je me souviens <br> Des jours anciens <br> Et je pleure <br> <br> Et je m’en vais <br> Au vent mauvais <br> Qui m’emporte <br> De?à, delà, <br> Parei <br></p>
</blockquote>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>诗文词曲</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐术语</title>
    <url>/2018/07/14/%E9%9F%B3%E4%B9%90%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<p>这是一个坑</p>
<p><code>$&#123;\rm &#125;$</code></p>
<h2 id="速度">速度</h2>
<ul>
<li>极慢板 <span class="math inline">\(({\rm Grave}\)</span> / <span class="math inline">\({\rm Larghissimo}\)</span> / <span class="math inline">\({\rm Lentissimo}\)</span> / <span class="math inline">\({\rm Adagissimo})\)</span></li>
<li>广板 <span class="math inline">\(({\rm Largo})\)</span>（<span class="math inline">\(40-60\)</span> bpm）</li>
<li>缓板 <span class="math inline">\({\rm (Lento)}\)</span></li>
<li>柔板 <span class="math inline">\({\rm (Adagio)}\)</span>（<span class="math inline">\(66-76\)</span> bpm）</li>
<li>小柔板 <span class="math inline">\({\rm (Adagietto)}\)</span> <a id="more"></a></li>
<li>小广板<span class="math inline">\({\rm (Larghetto) }\)</span>（60-66 bpm）</li>
<li>行板 <span class="math inline">\({\rm (Andante) }\)</span>（76-108 bpm）</li>
<li>小行板（Andantino）</li>
<li>中速（Moderato）（108-120 bpm）</li>
<li>小快板（Allegretto）</li>
<li>快板（Allegro）（120-168 bpm）</li>
<li>急板（Presto）（168-200 bpm）</li>
<li>最急板（Prestissimo / Vivacissimo）（200-208 bpm）</li>
<li>原速（A Tempo）</li>
<li>自由节奏（Rubato）</li>
<li>渐慢（Ritardando / rit）</li>
<li>突慢（Ritenuto / riten）</li>
</ul>
<h2 id="表情">表情</h2>
<ul>
<li>热情地（Appassionato）</li>
<li>辉煌地（Brillante）</li>
<li>滑稽地（Buffo）</li>
<li>如歌地（Cantabile）</li>
<li>有朝气地（Fresco）</li>
<li>诙谐地（Giocoso）</li>
<li>优美地（Con Grazio）</li>
<li>雄伟地（Grandioso）</li>
<li>高贵地（Maestoso）</li>
<li>田园风格（Tastorable）</li>
<li>庆典地（Festivo）</li>
<li>阴郁地（Lugubre）</li>
<li>哀伤地（Dolente）</li>
<li>哭泣地（Largemoso）</li>
<li>葬礼地（Funebre）</li>
<li>喧闹地（Strepitoso）</li>
<li>神秘地（Misterioso）</li>
<li>进行曲风格（Alla Marcia）</li>
<li>虔诚地（Religioso）</li>
<li>华彩乐段（Cadenza）</li>
<li>温柔地（Dolce）</li>
<li>温柔可爱（Con amore / Amoroso）</li>
<li>精神焕发，活泼生动（Animato / Animando / Con anima）</li>
<li>大胆（Ardito）</li>
<li>华丽（Brillante）</li>
<li>有精神（Brioso / Con brio）</li>
<li>轻浮（Frivole）</li>
<li>高尚（Generoso）</li>
</ul>
<h2 id="强弱">强弱</h2>
<ul>
<li>渐强（$Crescendo / cresc $）</li>
<li>渐弱（$Diminuendo / dim $）</li>
<li>最弱（<span class="math inline">\(Pianississimo / ppp\)</span>）</li>
<li>很弱（<span class="math inline">\(Pianissimo / pp\)</span>）</li>
<li>弱（<span class="math inline">\(Piano / p\)</span>）</li>
<li>中弱（<span class="math inline">\(Mezzo Piano / mp\)</span>）</li>
<li>中强（<span class="math inline">\(Mezzo Forte / mf\)</span>）</li>
<li>强（<span class="math inline">\(Forte / f\)</span>）</li>
<li>很强（<span class="math inline">\(Fortissimo / ff\)</span>）</li>
<li>最强（<span class="math inline">\(Fortississimo / fff\)</span>）</li>
<li>突强（<span class="math inline">\(Sforzando / sf / sfz\)</span>）</li>
<li>强后突弱（<span class="math inline">\(Forte Piano / fp\)</span>）</li>
</ul>
<h2 id="调">调</h2>
<h3 id="调式mode">调式(mode)</h3>
<p>调式是若干个具有不同音高的音的集合，这些音互相之间具有某种特定的音程关系，并在调式中担任不同的角色。调式是决定音乐风格最重要的因素之一。</p>
<p>调式和调性结合，决定了该段音乐所用的调。</p>
<p>将调式中的所有的音从主音开始，按照音高从低到高排成一列，就是该调式的音阶。</p>
<p>按照包含主音向上大三度还是小三度的音，绝大多数调式可以分为大调式和小调式两大类。</p>
<h3 id="调性tonality">调性(Tonality)</h3>
<p>调性(Tonality)是调的主音和调式类别的总称，例如，以<span class="math inline">\({\rm C}\)</span>为主音的大调式，其调性即是"<span class="math inline">\({\rm C}\)</span>大调"，以<span class="math inline">\({\rm a}\)</span>为主音的小调式，其调性就是“<span class="math inline">\({\rm a}\)</span>小调”等。以此类推，一般音乐中主要有24个调性。</p>
<h3 id="大调major">大调(Major)</h3>
<p>自然大调（经常简称为大调），即中古调式中的伊奥尼亚调式（Ionian），是调式的一种。自然大调包含七个音符，在唱名中分别是Do、Re、Mi、Fa、Sol、La、Si（或Ti）。</p>
<p>自然大调中的音符从主音开始，按照音高依次为主音、上主音、中音、下属音、属音、下中音和下主音，也可以称作主音、二级音、三级音、四级音等等。除了中音和下属音，下主音和主音之间是小二度，其他相邻两音之间都是大二度。</p>
<p>共有七种带升号的大调，分别有一至七个升号。将某个带升号大调的属音作为主音，即构成比它增加一个升号的大调。在调性标记中的升号就是按照这种顺序排列的。</p>
<p>共有七种带降号的大调，分别有一至七个降号。将某个带降号大调的下属音作为主音，即构成比它增加一个降号的大调。在调性标记中的降号就是按照这种顺序排列的。</p>
<p>有三对大调是同音异名的，它们是B大调与降C大调、升F大调和降G大调，以及升C大调与降D大调。同音异名的调虽然给人不同的调性感觉，但在平均律中音高是完全相同的。</p>
<h3 id="小调minor">小调(Minor)</h3>
<p>小调是相对于大调而言的，现代音乐两种主要调式之一。以音阶中的第六音为主音。</p>
<p>通常用以表达悲伤、阴沉、恐怖的情感，在动画或电影当中的背景音乐，则使用在悬疑或血腥等剧情上的使用，游戏当中则是战斗曲或是遭遇敌人魔王等。</p>
<p>自然小调，由自然音级所组成的小调，叫做“自然小调”。 结构为：“全音、半音、全音、全音、半音、全音、全音”，任何能构成这种结构的音阶都一定是自然小调。 A自然小调：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;A-&gt;G-&gt;F-&gt;E-&gt;D-&gt;C-&gt;B-&gt;A</p>
<p>和声小调，将自然小调的第VII级音升高半音，构成了和声小调。 A和声小调：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G?-&gt;A-&gt;G?-&gt;F-&gt;E-&gt;D-&gt;C-&gt;B-&gt;A</p>
<p>旋律小调，将自然小调的第VI级音、第VII级音同时升高半音，即构成了旋律小调。旋律小调的升高音级一般用于音阶的上行，而下行时与自然小调完全一致。 A旋律小调：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F?-&gt;G?-&gt;A-&gt;G?-&gt;F?-&gt;E-&gt;D-&gt;C-&gt;B-&gt;A</p>
<p>现代小调，上行或下行都跟旋律小调的音阶一样 A现代小调：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F?-&gt;G?-&gt;A-&gt;G?-&gt;F?-&gt;E-&gt;D-&gt;C-&gt;B-&gt;A ### 转调(Transpose) 转调，是在音乐进行中，从一种调（稳定的调）转入另一种新调的情况。新调被称为“副调”，副调未巩固前称为“离调”（临时转调），当属和弦（调式的五级和弦）、主和弦（调式的一级和弦）全部出现后，才算已经巩固，此时可称作是“转调”。</p>
<p>转调主要包括：</p>
<ul>
<li>同音列转调，只转移主音，音列不变。</li>
<li>同主音转调，主音不变，音列转换；</li>
<li>近关系转调，音高变化，新调和原调只相差一个升号或降号；</li>
<li>远关系转调，又名“疏远转调”，新调和原调相差不止一个升号或降号；</li>
<li>直接转调，又名“突然转调”，是直接由原调转向新调；</li>
<li>间接转调，又名“逐渐转调”，是通过若干中间调而最后转向新调；</li>
<li>长时转调，转入新调的时间较长，并在新调上结束音乐段落。</li>
</ul>
<p>转调能使乐曲增加变化，丰富乐曲的表现力，对音乐发展和进行起到重要的作用。</p>
<h3 id="二重调性">二重调性</h3>
<p><del>没找到资料</del></p>
<h2 id="和声">和声</h2>
<ul>
<li>和弦（Chord）</li>
<li>和声（Harmony）</li>
<li>和谐音 / 不和谐音（Consonant / Disconsonant）</li>
</ul>
<h2 id="泛音">泛音</h2>
<ul>
<li>基本频率</li>
<li>旋律（Melody）</li>
<li>旋律（Melody）</li>
<li>音阶（scale）</li>
<li>音程（Interval）</li>
<li>音高（pitch）</li>
<li>音域</li>
<li>音色（Colour）</li>
<li>乐句</li>
<li>声部</li>
<li>切分音（Syncopation）</li>
</ul>
<h2 id="曲式">曲式</h2>
<ul>
<li><p>二段体（Binary）</p></li>
<li><p>三段体（Ternary）</p></li>
<li><p>奏鸣曲式（Sonata form）</p></li>
<li><p>呈示部（Exposition）</p></li>
<li><p>展开部（Development）</p></li>
<li><p>再现部（Recapitulation）</p></li>
<li><p>回旋曲式（Rondo）</p></li>
<li><p>赋格（Fugue）</p></li>
<li><p>二重奏Duet 由两件乐器分奏两个声部的室内乐</p></li>
<li><p>三重奏Trio 由三件乐器分奏三个声部的室内乐</p></li>
<li><p>弦乐三重奏string trio 由小提琴、中提琴、大提琴分奏三个声部的室内乐</p></li>
<li><p>钢琴三重奏piano trio 由钢琴与另两件乐器（弦乐器或管乐器）演奏的室内乐</p></li>
<li><p>四重奏quartet 由四件乐器分奏四个声部的室内乐</p></li>
<li><p>弦乐四重奏string quartet 由两个小提琴，一个中提琴、一个大提琴演奏的室内乐</p></li>
<li><p>五重奏quintet<br />
由五件乐器分奏五个声部的室内乐</p></li>
<li><p>弦乐五重奏string quintet 由两把小提琴、两把中提琴、一把大提琴（或一把中提琴、两把大提琴）演奏的室内乐 　</p></li>
<li><p>钢琴五重奏piano quintet 由四件弦乐器与钢琴演奏的室内乐</p></li>
<li><p>歌剧opera 综合音乐、诗歌、舞蹈等艺术而以歌唱为主的一种戏剧形式。</p></li>
<li><p>轻歌剧operetta 题材轻松、内容抒情、结构短小的一种戏剧性歌剧</p></li>
<li><p>音乐喜剧musical comedy 融戏剧、歌舞、音乐于一体的一种音乐剧。富于幽默情趣与戏剧色彩，音乐通俗易懂。</p></li>
<li><p>咏叹调aria 西洋歌剧、清唱剧或康塔塔中的独唱曲</p></li>
<li><p>宣叙调recitative 一种用以代替对白的歌剧。节奏自由，曲调接近与朗诵</p></li>
<li><p>歌曲song 由歌词和音乐相结合、以表达思想、抒发情感的一种声乐体裁。</p></li>
</ul>
<p>艺术歌曲art song 侧重表现人的内心世界，歌词多采用著名诗词，曲调表现力强的抒情歌曲 　 声乐套曲song cycle 以同一诗人的诗为歌词，由一组内容为同一主题，同一故事歌曲组成的音乐统一体 　 民歌folksong 民间口头流传的歌曲 　 牧歌madrigal 由14世纪意大利田园曲演变成的多声部声乐曲 　 清唱剧oratorio 神剧或圣剧，介于歌剧和康塔塔之间的多乐章大型声乐套曲 　 康塔塔cantata 多乐章的大型声乐套曲 　 大合唱grand vocal cycle 包括独唱、重唱、对唱、齐唱与合唱（有时穿插朗诵）的，通常由管弦乐队伴奏的多乐章的大型声乐套曲 　 声部voice 凡结合两行以上的旋律或两个以上的音同时进行的音乐，称多声部音乐，其中每一行旋律或构成和弦进行的每一条音的线条即为一个声部 　 美声唱法bel canto 意大利文为优美的歌唱，并兼有美丽的歌曲的含义 　 女高音soprano 女声音域中最高的声部 　 次女高音mezzo soprano 次于女高音的女声。音域在女高音与女中音之间。（有人将次女高音称为女中音） 　 女中音alto或contralto 女声最低的声部。（有人将女中音称为女低音） 　 抒情女高音Lyric soprano 音色柔美、清丽的女高音 　 花腔女高音coloratura soprano 音色绚丽轻巧而富有弹性的女高音 　 戏剧女高音dramaltic soprano 音色壮实，浑厚有力的女高音 　 男高音tenor 最高的男声 　 男中音bariton 次于男高音的男声 　 男低音bass 次于男中音的男声 　 抒情男高音Lyric tenor 音色恬美柔和而富于歌唱性的男高音 　 戏剧男高音</p>
<p>dramatic tenor 音色浓厚、壮实而饱满的富有英雄气慨的男高音 　 童声child’s voice 少年儿童在未变声以前的嗓音，音色与女声相似。无男女之分 　 假声falsetto 人们日常说话的声音为真声，与之不同的发声状态所发出的声音（男作女）为假声。其为成人的最高声区 　 经文歌motet 欧洲中世纪和文艺复兴时期演唱解释《圣经》的复调合唱歌曲 　 弥撒mass 天主教在举行弥撒仪式时所唱的复调风格声乐套曲 　 安魂曲requiem 追思曲。一种用于天主教追悼仪式的合唱套曲 　 音程interval 指两音间的距离，计算单位为“度” 　 音名pitch names 指西洋音乐中的七个基本音级的名称，即CDEFGAB 　 唱名syllable names 把七个基本音级依次唱出来的do、re、mi、fa、sol、la、si为唱名，简谱写作1234567 　 音区register 乐器或人声的整个音域 　 音域range 指某一乐器或人声所能发出的最低音到最高音之间的范围 　 标准音standard pitch 指音乐中用作定音标准的a1音，其频率为440赫兹。也就是C大调音阶中6（la）这个音 　 音高pitch 听觉赖以分辨乐音高低的一种特性 　 音阶scale 指调式中的各音从主音到其八度音，按音高次序排列而成的音列（如C大调的音阶为1234567i） 　 调式mode 指音阶的不同的组合形式。西洋音乐有大调式与小调式之分。 　 调key 调门。一般指某个调式的主音（起始音）的音高，这个主音音高的音名，就是这个调式的调（调门）的名称。 　 旋律melody 曲调。指音与音有组织的横向组合 　 节奏rhythm 指音的长短、强弱作周期性的变化的形态。一般将节奏、旋律、和声三者称为音乐形成的三大要素 　 节拍meter 乐曲中周期性出现的节奏序列 　 和声harmony 指两个以上的音按一定的音和关系同时发声的纵向组合。 　 速度tempo 指音乐进行时节拍的相对快慢程度 　 力度dynamics 指音乐演奏时音响的强弱程度。 　 曲式form 指乐曲的结构形式。其基本的模式有两种：二段式（二部曲式）和三段式（三部曲式） 　 主题theme 乐曲中具有特征的并处于显著地位的旋律。 　 副歌accessory theme 指一首歌曲中每遍所唱的歌词都相同的部分。起着集中表达全曲中心思想的作用 　 乐句phrase 由许多乐节组成的，能表达一定意思的一个旋律 　 乐段period 由若干乐句组成的，表现一段大致完整的乐思的段落 　 二段体binary form 指由两个乐段组成的曲式，前后两段形成对比 　 三段体fernary form 由三个乐段组成的曲式。第一段与第三段相同或基本相同，第二段则具有对比性质 　 复三段体compound ternary form 由三个二段体或三段体组成的曲式。 　 乐章movement 大型套曲中在结构上有相对独立性的一个章节 　 前奏anabole 乐曲前面的序奏 　 华彩段cadenza 乐曲中由独奏者自由发挥其表演技术的段落，通常乐队暂停演奏 　 尾声postlude 指乐曲的结束部分，起着补充总结或推向高潮的作用 　 单声音乐monophony 由单一旋律所构成的音乐，包括没有伴奏的独唱、独奏、以及旋律作同度或八度重叠的齐唱、齐奏。 　 复调音乐polyphony 由若干旋律性声部同时进行而组成的乐曲，其每一个声部都同等地重要并具有独立性，但同时各声部又彼此形成和声关系 　 主调音乐homophony 在众多的声部中，以一个旋律性最强的声部为主，其余声部作为陪衬 　 指挥conductor 领导乐队或合唱队进行排练和演出的人</p>
<p>标题音乐program music 有文字说明乐曲内容的音乐作品。</p>
<p>古典音乐classical music 泛指时指过去时代具有典范意义或代表性的音乐（不含民间音乐）；专指时指维也纳古曲乐派的音乐或师法于该乐派的音乐 　 爵士乐Jazz 本世纪初产生于叛国新奥尔良的一种溶合了黑人的散拍乐，灵歌与布鲁斯的音乐形式。 　 管弦乐团orchestra 由弦乐器、管乐器与打击乐器组成的大型器乐合奏团体。 　 交响乐团symphony orchestra 指大型的管弦乐团 　 铜管乐团brass band 由铜管乐器和部分打击乐器组成的乐团，其有别于兼有木管乐器的管乐团 　 管乐团wind band 由木管乐器、钢管乐器和打击乐器组成的吹奏乐团，也泛指军队中的军乐团或同一类型的管乐团 　 铜鼓乐团steel band 由不同类型的铜鼓所组成的乐团，人数几十至百余人不等</p>
<p>套曲Cycle 一种由多乐章组合而成的大型器乐曲或声乐曲 　 组曲Suite 由几个具有相对独立性的器乐曲组成的乐曲 行星组曲，培尔.金特组曲</p>
<p>奏鸣曲Sonata 指类似组曲的器乐合奏套曲.自海顿.莫扎特以后,其指由3-4个乐章组成的器乐独奏套曲(钢琴奏鸣曲)或独奏乐器与钢琴合奏的器乐曲(小提琴奏鸣曲) 　 交响曲symphony 大型管弦乐套曲,通常含四个乐章.其乐章结构与独奏的奏鸣曲相同 　 协奏曲concerto 由一件或多件独奏乐器与管弦乐团相互竞奏,并显示其个性及技巧的大型器乐套曲.分独奏协奏曲、大协奏曲、小协奏曲等 　 交响诗symphonic poem 单乐章的标题性交响音乐 　 音诗poeme 单乐章管弦乐曲，与交响诗相类似 　 序曲overture 歌剧、清唱剧、舞剧、其他戏剧作品和声乐、器乐套曲的开始曲。十九世纪又出现独立的音乐会序曲 　 前奏曲prelude 带有即兴曲的性质、有独立的乐思、常放在具有严谨结构的乐曲或套曲之前作为序引的中、小型器乐曲。 　 托卡塔toccata 节奏紧凑、快速触键的富有自由即兴性的键盘乐曲 　 幻想曲fantasia 形式自由，给人以即兴创作或自由幻想之感的器乐曲 　 随想曲capriccio 形式自由的赋格式的幻想曲，19世纪后是一种富于幻想的即兴性器乐曲 　 狂想曲rhapsody 始于19世纪初以民族或民间曲调为主要素材的具有鲜明民族特色的器乐幻想曲 　 练习曲study 为提高乐器演奏者技术水平而写的乐曲 　 无词歌songs wighout 抒情的小型器乐曲，有伴奏声部，旋律声部象歌曲样的钢琴曲 　 浪漫曲Romance 罗曼司，主要指具有抒情性的声乐曲和富有歌唱性的器乐曲 　 叙事曲ballade 富于叙事性、戏剧性的钢琴独奏曲 　 夜曲nocturne 流行于18世纪西洋贵族社会中的器乐套曲，常在夜间露天演奏 　 小夜曲serenade 晨歌的对称。起源于中世纪欧洲吟唱诗人在恋人窗前所唱的情歌 　 谐谑曲scherzo 诙谐曲。节奏强烈，速度较快、轻松活泼的三拍子器乐曲或声乐曲 　 间奏曲intermezzo 为歌剧或戏剧中的过场音乐或幕间曲；另一种为形式较自由篇幅较小的器乐曲 　 赋格曲fugue 拉丁文音译意为遁走。以复调手法写成的大型乐曲 　 卡农canon 纯以模仿手法构成的复调音乐形式 　 轮唱曲round 用同度或八度卡农手法写成的声乐曲 　 创意曲invention 复调结构的钢琴小曲。类似前奏曲或小赋格曲。巴赫始用此名称 　 练声曲vocalization 没有歌词而用韵母、音节或唱名演唱的声乐练习曲 　 回旋曲rondo 由相同的主部和几个不同的插部交替出现而构成的乐曲 　 变奏曲variation 主题及其一系列变化反复，并按照统一的艺术构思而组成的乐曲 　 进行曲march 用步伐节奏写成的乐曲 　 特性曲character piece 指富于诗情画意和生活情趣的器乐小曲，主要是钢琴小曲 　 晨歌alborada 起源于西班牙西北部的加利西亚的田园风味乐曲 　 田园曲pastorable 原为欧洲16-17世纪一种乡村题材的戏剧表演，歌剧的前身之一。近代音乐中是模仿牧人所吹肖姆管曲调和圣诞吹奏乐的器乐曲或声乐曲，源于意大利。 　 船歌barcarolle 威尼斯船工所唱的歌曲以及模仿这种歌曲的声乐曲和器乐曲 　 悲歌elegy 表现哀伤情绪的声乐曲或器乐曲 　 摇篮曲berceuse 抒情声乐曲或器乐曲。描写摇篮摆动的节奏，近似船歌。 　 嬉游曲divertimento 18世纪欢娱宾客的一种器乐重奏组曲 　 即兴曲impromptu 偶发创作的抒情特性曲，19世纪成为器乐短曲曲名，形式类似歌曲 　 无穷动perpetuum mobile 从头至尾贯穿着急速节奏的乐曲 　 小品bagatelle 轻快，幽默的特性曲，常为钢琴小曲 　 幽默曲humoreske 富于幽默风趣或表现恬淡朴素、明朗愉快情致的器乐曲 　 新事曲novellette 始创于R.舒曼的一种钢琴特性曲 　 演绎曲paraphrase 14--16世纪教会音乐中的演绎曲是自由加工的素歌旋律。F.李斯特借用此名称称其为著名声乐曲和器乐曲，特别是为歌剧选曲所作的钢琴改编曲为演绎曲 　 舞曲dance music 根据舞蹈节奏写成的器乐曲或声乐曲 　 小步舞曲menuet 起源于法国民间的三拍子舞曲，因舞步极小而得名 　 加沃特gavotte 起源于法国民间的中速、四拍子舞曲 　 塔兰泰拉tarantella 起源于意大利的速度迅急、情绪热烈的舞曲 　 波尔卡polka 起源于捷克的速度较快的二拍子舞曲 　 华尔兹waltz 圆舞曲。一种起源于奥地利民间的三拍子舞曲。 　 玛祖卡mazurka 起源于波兰民间的情绪活泼热烈的三拍子双人舞曲 　 波罗乃兹polonaise 波兰舞曲。起源于波兰民间的庄重，缓慢的三拍子舞曲 　 哈巴涅拉habanera 阿伐奈拉。由非洲黑人传入古巴的中速二拍子舞曲 　 探戈tango 起源非洲后传入阿根廷的中速、二拍子或四拍子的舞曲 　 独唱solo 由一人演唱，常用乐器或乐队伴奏的演唱形式，有时也用人声伴唱 　 齐唱unison 两人以上的歌唱者，按同度或八度音程关系同时演唱同一旋律的演唱形式 　 重唱ensemble 每个声部均由一人演唱的多声部声乐曲及演唱形式。按声部或人数分二重唱、三重唱、四重唱 　 领唱lead a chorus 由一人唱众人和的演唱形式 　 合唱chorus 两组以上的演唱者，各按本组所担任的声部演唱同一乐曲的演唱形式 　 无伴奏合唱a cappella 纯粹由人声演唱不用乐器伴奏的合唱形式 　 合奏ensemble 由多种乐器组成，常按乐器种类的不同而分为若干组，各组分别担任某些声部，演奏同一乐曲的演奏形式 　 伴奏accompaniment 由一件或多件乐器奏出，用以衬托主要的歌唱或器乐演奏部分。用以烘托舞蹈的器乐配乐也常称为伴奏 　 独奏solo 由一人演奏某一乐器，常用其他乐器或乐队伴奏 　 齐奏unison 两个以上的演奏者，按同度或八度音程关系同时演奏同一曲调 　 室内乐chamber music 通常指由少数人演奏，演唱的重奏曲、重唱曲。 　</p>
<p>参考资料</p>
<blockquote>
<p>https://zh.wikipedia.org/wiki/%E9%9F%B3%E4%B9%90%E6%9C%AF%E8%AF%AD%E5%88%97%E8%A1%A8 <br>https://zh.wikipedia.org/zh-hans/%E9%9F%B3%E4%B9%90%E5%BD%A2%E5%BC%8F%E5%88%97%E8%A1%A8 <br>http://www.360doc.com/content/15/0304/20/10220466_452572138.shtml</p>
</blockquote>
]]></content>
      <categories>
        <category>Music</category>
      </categories>
  </entry>
  <entry>
    <title>电脑使用指南</title>
    <url>/2020/08/21/how_to_use_computer_correctly/</url>
    <content><![CDATA[<p><strong>建议在电脑上打开此文阅读</strong></p>
<a id="more"></a>
<h2 id="软件">软件</h2>
<ul>
<li>浏览器：<a href="https://dl.google.com/tag/s/appguid%3D%7B8A69D345-D564-463C-AFF1-A69D9E530F96%7D%26iid%3D%7B84587115-C6CA-1C8C-3838-F68C04C64A3C%7D%26lang%3Dzh-CN%26browser%3D4%26usagestats%3D1%26appname%3DGoogle%2520Chrome%26needsadmin%3Dprefers%26ap%3Dx64-stable-statsdef_1%26installdataindex%3Dempty/update2/installers/ChromeSetup.exe">Chrome</a>(可以把联想浏览器卸了
<ul>
<li>chrome中推荐使用的插件：<a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm?utm_source=chrome-ntp-icon">uBlock Origin</a> <a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?utm_source=chrome-ntp-icon">Tampermonkey</a>(<a href="https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;mid=2247484033&amp;idx=1&amp;sn=1d75f73d10e56d105f35d0c2e1b16d86&amp;scene=21#wechat_redirect">使用指南</a>)</li>
</ul></li>
<li>杀毒软件：<a href="https://www.huorong.cn/">火绒</a> 选择个人用户版下载 安好后记得在“安全工具”中开启弹窗拦截</li>
<li>解压软件：<a href="https://cn.bandisoft.com/bandizip/">Bandzip</a></li>
<li>播放软件：<a href="/download/PotPlayerSetup64.exe">PotPlayer</a></li>
<li>ppt辅助工具：<a href="https://www.islide.cc/">islide</a></li>
<li><a href="https://support.microsoft.com/zh-cn/help/17205/windows-10-create-films-with-video-editor">win10自带的视频编辑器</a> <a href="https://zhuanlan.zhihu.com/p/58116160">其他教程</a></li>
<li>安装软件时路径尽量不要有中文</li>
<li>注意不要乱安装来路不明的软件</li>
</ul>
<h2 id="基本操作">基本操作</h2>
<ul>
<li><a href="https://sspai.com/post/45594">关于win10的多虚拟桌面使用</a></li>
<li><a href="https://www.zhihu.com/question/26812365/answer/850878582">快捷键</a></li>
<li>截图请使用<code>win+PrtScn</code>（保存在个人文件夹/图片/屏幕截图中）或者<code>win+w</code>中使用"全屏截图"，或者安装<a href="https://zh.snipaste.com/">snipaste</a>，<strong>不要用手机拍屏幕！！！</strong></li>
</ul>
<h2 id="硬件外设">硬件(外设)</h2>
<ul>
<li><del>考虑到联想国内自带的联想电脑管家弹窗可能有点多，可将其卸载并点击<a href="https://www.microsoft.com/zh-cn/p/lenovo-vantage/9wzdncrfj4mv#activetab=pivot:overviewtab">此处</a>或在win10应用商店中搜索"Lenovo vantage"(其实就是国际版)并安装以替代</del>刚了解了一下，发现它已经从良了，就不用搞了</li>
<li>由于联想自带的电源适配器过于笨重，可购买<a href="https://item.jd.com/100012368380.html?cu=true&amp;utm_source=kong&amp;utm_medium=tuiguang&amp;utm_campaign=t_1001542270_1001352649_0_1884133294&amp;utm_term=ebb23d1f99d04387a429c9d32341a386">这个</a>(京东学生认证后仅需89，也可购买合适的GaN充电器</li>
<li>未完待续？</li>
</ul>
]]></content>
      <categories>
        <category>电脑使用相关</category>
      </categories>
  </entry>
</search>
